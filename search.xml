<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>信息检索</title>
    <url>/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<!-- build time:Sun Feb 23 2020 16:28:39 GMT+0800 (GMT+08:00) --><h2 id="引言">引言</h2><ul><li>考核：平时作业（实践10%）+综合实践（期末大作业20%）+闭卷考试（70%）</li><li>课程邮箱：njuir@sina.com</li><li>现代信息技术的范畴：计算机技术、通讯技术、微电子技术、传感技术</li><li>信息技术的发展节点<ul><li>语言：猿到人的重要标志</li><li>文字：信息存储和传递突破时间和空间的限制</li><li>造纸与印刷术：知识的大规模传递</li><li>电报电话电视：光（电）速带来传播效率的飞跃</li><li>计算机及现代通讯：机器开始代替人工</li></ul></li><li>信息素养：掌握了信息工具利用的知识与技能，并能够应用于解决实际问题的人</li><li>EXIF格式：记录数码照片的属性信息和拍摄数据，包含了地点信息</li><li>信息管理基本流程<ul><li>信息采集<span class="math inline">\(\rightarrow\)</span>信息加工<span class="math inline">\(\rightarrow\)</span>信息组织<span class="math inline">\(\rightarrow\)</span>信息检索<span class="math inline">\(\rightarrow\)</span>信息分析<span class="math inline">\(\rightarrow\)</span>信息预测<span class="math inline">\(\rightarrow\)</span>信息服务</li><li>无序信息<span class="math inline">\(\rightarrow\)</span>有序信息<span class="math inline">\(\rightarrow\)</span>可用信息</li></ul></li></ul><h2 id="第一章">第一章</h2><h3 id="基本概念">基本概念</h3><ul><li>数据：事实或观察的结果，是对客观事物的性质、状态以及相互关系等进行记载的物理符号，可离散（数字数据）、连续（模拟数据）<ul><li>数据需要经过解释才能体现价值</li><li>数据加工后就成为信息</li></ul></li><li>信息：（信息论、控制论和经济都有不同的解释）<ul><li>对信息进行提炼、推理后获得的正确理论是知识</li></ul></li><li>知识：正确结论、信息集合<ul><li>知识传输一般遵循的模式：传输者的知识<span class="math inline">\(\rightarrow\)</span>数据<span class="math inline">\(\rightarrow\)</span>信息<span class="math inline">\(\rightarrow\)</span>接收者的知识</li></ul></li><li>情报：（军事情报观、信息情报观、知识情报观有不同解释）</li><li>文献：用文字、图形、符号、声频、视频等技术手段记录人类知识的一种载体</li></ul><h3 id="基本概念的转换">基本概念的转换</h3><ul><li>知识--表达--&gt;数据--背景--&gt;信息--经验--&gt;知识</li></ul><h3 id="基本概念的包容">基本概念的包容</h3><ul><li>数据是事实的数字化、编码化、序列化、结构化；</li><li>信息是数据在信息媒体上的映射；</li><li>知识是对信息的加工、吸收、提取和评价的结果；</li><li>情报是特指的专业信息，是传播中的知识（知识与情报有交叉）</li><li>文献是载体</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>信息检索</category>
      </categories>
      <tags>
        <tag>大三下</tag>
        <tag>信息检索</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--数组专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Sun Feb 23 2020 16:28:39 GMT+0800 (GMT+08:00) --><h2 id="盛最多水的容器">盛最多水的容器</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">【LeetCode】盛最多水的容器</a></p><p>题目意思就是找到如下图所示最大的面积<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="题图">，挑战性在于希望在<span class="math inline">\(O(n)\)</span>时间复杂度内完成查找。</p><p>我的思路是使用两个指针分别指向头尾两个高度，让指向较短线段的指针向另外一个指针移动。因为移动较短线段的指针会得到一条相对较长的线段，这可以克服由宽度减小而引起的面积减小。反之则必然引起面积缩小。C++代码实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> delta=last-prev;</span><br><span class="line">    <span class="keyword">int</span> maxArea=<span class="built_in">min</span>(<span class="built_in">height</span>[prev],<span class="built_in">height</span>[last])*delta;</span><br><span class="line">    <span class="keyword">int</span> tempArea=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(delta)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height</span>[prev]&lt;=<span class="built_in">height</span>[last])&#123;</span><br><span class="line">            ++prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            --last;</span><br><span class="line">        &#125;</span><br><span class="line">        --delta;</span><br><span class="line">        tempArea=<span class="built_in">min</span>(<span class="built_in">height</span>[prev],<span class="built_in">height</span>[last])*delta;</span><br><span class="line">        maxArea=(tempArea&gt;maxArea)?tempArea:maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意到这里面用了一些涉及到编译和汇编的小trick提升了执行速度，提交界面显示执行时间超过90.70%的用户。</p><h2 id="pat-ranking">PAT Ranking</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805474338127872" target="_blank" rel="noopener">【PAT A1025】PAT Ranking</a></p><p>题目主要考察的就是模拟一个有优先级的排序算法，编写程序的过程中发现自己两点不足：</p><ol type="1"><li>cmp函数编写不熟练；</li><li>题目要求“the registration number (a 13-digit number)”，表明肯定不能直接使用int类型变量记录准考证号，应该考虑使用char字符数组记录。</li><li>vector使用不熟练，注意初始化n行元素类型为Info的二维数组应该用语句<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Info&gt;&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p>下面把cmp函数代码贴出，供以后复习参考：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Info &amp;a,<span class="keyword">const</span> Info &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score==b.score)&#123;</span><br><span class="line">        <span class="comment">//Sort by regNum in a non-decreasing </span></span><br><span class="line">        <span class="comment">//order if the scores are the same.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.regNum,b.regNum)&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据实验</title>
    <url>/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<!-- build time:Sun Feb 23 2020 16:28:39 GMT+0800 (GMT+08:00) --><h2 id="课程相关">课程相关</h2><ul><li>成绩组成<ul><li>期末考试50%，基本原理、方法、概念、书面编程题</li><li>课程实验25%，5次，每次5%，共计25%</li><li>课程设计25%，暑期7月份有20多天完成</li></ul></li><li>教材：深入理解大数据——大数据编程技术与实践</li></ul><h2 id="为什么要并行计算">为什么要并行计算</h2><ul><li>提高计算机性能的主要手段<ul><li>提高处理器字长</li><li>提高集成度</li><li>流水线等微体系结构技术：实现指令级并行<ul><li>RISC结构</li><li>5级流水线</li><li>分支预测</li><li>寄存器重命名</li><li>超长指令字、乱标量等……</li></ul></li><li>提高处理器频率</li></ul></li><li>为什么需要并行计算？<ul><li>单核处理器性能提升接近极限<ul><li>VLSI集成度不可能无限制提高</li><li>ILP墙：处理器的指令级并行度提升接近极限</li><li>存储墙：处理器速度和存储器速度差异越来越大</li><li>功耗墙：功耗和散热大幅增加超过芯片承受能力</li></ul></li><li>单处理器向多核/众核并行计算发展成为必然趋势<ul><li>多（Multicore）核并行计算</li><li>众（Manycore）核并行计算</li></ul></li><li>应用领域计算规模和复杂度大幅度提高<ul><li>爆炸性增长的Web规模数据量</li><li>超大的计算量/计算复杂度 ## 并行计算技术的分类</li></ul></li></ul></li><li>按数据和指令处理结构：弗林(Flynn)分类（体系结构角度分类）<ul><li>单指令单数据流(SISD)、单指令多数据流(SIMD)、多指令单数据流(MISD)：很少使用、多指令多数据流(MIMD)：最常用</li></ul></li><li>按并行类型（应用角度分类）<ul><li>位级并行、指令级并行、线程级并行（数据级并行、任务级并行）</li></ul></li><li>按存储访问构架<ul><li>共享内存（也称UMA）：通过总线共享内存</li><li>分布共享存储体系结构：各处理器本地有存储器，同时共享全局存储器</li><li>分布式内存：各处理器使用本地独立的存储器</li></ul></li><li>按系统类型<ul><li>多核/众核并行计算系统(MC)、对称多处理器系统(SMP)、大规模并行处理(MPP)、集群(Cluster)、网格(Grid)</li><li>上面几种系统类型中耦合度越前面越高，可扩展性越后面越高，系统规模越后面越高、能耗（一般来说与系统规模成正比）越后面越高</li></ul></li><li>按计算特征：大数据时代主要解决数据密集型和混合型并行计算<ul><li>数据密集型并行计算：如大规模Web信息搜索</li><li>计算密集型并行计算：如3D建模与渲染、气象预报、科学计算</li><li>数据密集型与计算密集型混合型并行计算：3D电影渲染</li></ul></li><li>按并行程序设计模型/方法<ul><li>共享内存变量：如pthread、OpenMp</li><li>消息传递方式：如MPI</li><li>MapReduce方式：MapReduce并行程序设计模型 ## 并行计算的主要技术问题 <em>数据怎么存，怎么算？（并行算法、软件构架、硬件构架）</em></li></ul></li><li>多核/多处理器网络互连结构技术</li><li>存储访问体系结构<ul><li>共享存储器体系结构</li><li>分布存储体系结构</li><li>分布共享存储体系结构</li></ul></li><li>分布式数据与文件管理</li><li>并行计算任务分解与算法设计</li><li>并行程序设计模型和方法<ul><li>共享内存式（适用共享内存结构）、消息传递式（适用分布内存结构）、MapReduce并行程序设计</li><li>并行程序设计语言<ul><li>语言、库函数、接口</li></ul></li><li>并行编译优化</li></ul></li><li>数据同步访问和通信控制</li><li>可靠性技术与容错技术<ul><li>数据失效恢复、系统和任务失效恢复</li></ul></li><li>并行计算软件框架平台<ul><li>提供自动化并行处理能力</li><li>高可拓展性和系统性能提升</li></ul></li><li>系统性能评价和程序并行度评估<ul><li>系统性能评价：例如Benchmark等</li><li>程序并行度评估<ul><li>程序并行加速评估公式<strong>Amdahl定律,其中<span class="math inline">\(S\)</span>是加速比，<span class="math inline">\(P\)</span>是程序可并行比例、<span class="math inline">\(N\)</span>是处理器数目：（需要掌握）</strong> <span class="math display">\[S=\frac{1}{1-P+\frac{P}{N}}\]</span></li><li>所以，<strong>一个并行程序可加速程度是有限制的，并非无限加速，也并非程序越多越好</strong></li></ul></li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>大数据实验</category>
      </categories>
      <tags>
        <tag>大三下</tag>
        <tag>大数据实验</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘导论</title>
    <url>/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AF%BC%E8%AE%BA/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<!-- build time:Sun Feb 23 2020 16:28:39 GMT+0800 (GMT+08:00) --><h2 id="课程信息">课程信息</h2><ul><li>教材：Data Mining: Concepts and Techniques, 3rd edition. Elsevier Inc, 2012</li><li>成绩：<ul><li>Final exam 闭卷(30%)</li><li>Assignments (30%)</li><li>Data Mining Practice (40%)<ul><li>5月左右布置，有一个月左右时间完成</li></ul></li></ul></li><li>目标：锻炼数据思维<ul><li>科学研究的第四范式：基于数据的角度，“万物皆数据”</li></ul></li></ul><h2 id="引言">引言</h2><ul><li>先决条件：计算机硬件、软件技术、网络<span class="math inline">\(\rightarrow\)</span>采集数据方便且海量<span class="math inline">\(\rightarrow\)</span>大数据</li><li>为什么要数据挖掘？<ul><li>大数据有巨大的价值，Data are rich</li><li>但是大数据太多了，无法找到有用的信息，Info is poor</li></ul></li><li>数据挖掘得到什么？<ul><li>知识、关系、真理<span class="math inline">\(\rightarrow\)</span>对决策有用的信息</li></ul></li><li>举例<ul><li>超市购买商品：啤酒和尿布</li><li>潜在客户挖掘：哪些客户会从2G转化为3G？</li><li>网络入侵模式：决定当前结点正在被侵入</li><li>基因数据挖掘：通过基因表达确定基因功能</li><li>医疗数据挖掘：计算机辅助诊断</li><li>网络挖掘：网络结构、网页内容、使用习惯等用来网络搜索、用户行为检测</li><li>金融数据挖掘：欺诈检测、股票趋势发现</li><li>软件数据挖掘：挖掘源代码、运行时间等提升软件质量、生产效率、用户体验等</li><li>行为数据挖掘：Kinect</li><li>艺术数据挖掘：挖掘绘画的笔触、鉴定真伪、改变照片风格</li><li>语音生成：为无声视频产生音频</li><li>图像、视频编辑</li><li>总统竞选</li></ul></li><li>数据挖掘定义？没有确切定义<ul><li>数据挖掘是从<strong>巨量数据</strong>中获取<strong>正确的、新颖的、潜在有用的、最终可理解</strong>的模式的<strong>非平凡</strong>过程</li><li>最终可理解？其实一部分机器学习方法是不可理解的，因此一定要注意有些情况下可理解性必须要有，而有些情况下可理解性可不必有。</li></ul></li><li>Knowledge Discovery in Data(KDD)<ul><li>数据清洗、数据仓库、数据选择、数据挖掘、……</li></ul></li><li>DM和KDD的关系？<ul><li>包含、被包含、相等都有道理</li><li>现在绝大部分人认为二者都是对数据分析处理，是相同的概念</li></ul></li><li>什么数据可以被挖掘？<ul><li>&quot;Flat&quot; data: table or matrix</li><li>数据仓库（Data warehouse）</li><li>文本数据（Text data）</li><li>多媒体数据（Multimedia data）：音频、视频、图像等</li><li>网络数据（Web data）</li><li>社交网络数据（Social network data）</li><li>时间、空间数据（Temporal and spatial data）</li></ul></li><li>数据挖掘任务分类<ul><li>描述型挖掘任务：数据的总体性质，例如分布、统计量等</li><li>预测型挖掘任务：建立模型来预测未来的事件，数量应该较描述型任务更多</li></ul></li><li>哪一些模式可以被挖掘？</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据挖掘导论</category>
      </categories>
      <tags>
        <tag>大三下</tag>
        <tag>数据挖掘导论</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--链表专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Sun Feb 23 2020 16:28:39 GMT+0800 (GMT+08:00) --><p><em>昨天晚上临睡前突然想到反转链表的操作自己不太熟悉，然后2019年冬季PAT考试刚好考了每k个结点为一组反转链表的题目，而自己却不太会做。因此想要着手撰写这个专题，辅以LeetCode评判系统测试正确性，用以复习链表操作。</em></p><h2 id="反转链表">反转链表</h2><h3 id="反转整个链表">反转整个链表</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">【LeetCode 206】Reverse Linked List</a></p><p>题目的意思直接明了，挑战性在于要一次遍历完链表且不消耗过多的额外空间。这里主要采用三指针迭代的方式求解。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *prev=<span class="literal">NULL</span>;</span><br><span class="line">    ListNode *curr=head;</span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        ListNode *nextTemp=curr-&gt;next;</span><br><span class="line">        curr-&gt;next=prev;</span><br><span class="line">        prev=curr;</span><br><span class="line">        curr=nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="每k个结点为一组反转链表">每k个结点为一组反转链表</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">【LeetCode 25】Reverse Nodes in k-Group</a></p><p>题目的挑战性在于一次遍历就要完成每k个结点反转链表，并且只允许常数级别的额外空间。这里主要采用尾插法解题：即每次遍历到第k个结点，将该组头节点插入第k个结点后面，再将新的该组头节点插入第k个结点后面，以此类推。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* temp=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    temp-&gt;next=head;</span><br><span class="line">    ListNode* grpHead=temp;</span><br><span class="line">    ListNode* grpTail=temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(grpTail!=<span class="literal">NULL</span>&amp;&amp;count&lt;k)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">            grpTail=grpTail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grpTail==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tempHead=grpHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(grpHead-&gt;next!=grpTail)&#123;</span><br><span class="line">            ListNode *curNode=grpHead-&gt;next;</span><br><span class="line">            grpHead-&gt;next=curNode-&gt;next;</span><br><span class="line">            curNode-&gt;next=grpTail-&gt;next;</span><br><span class="line">            grpTail-&gt;next=curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        grpHead=tempHead;</span><br><span class="line">        grpTail=tempHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="移去链表末尾的第n个结点">移去链表末尾的第n个结点</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">【LeetCode 19】Remove Nth Node From End of List</a></p><p>题目意思是移除单向链表的倒数第n个结点，要求遍历一次就可以移除。这里的基本思路是双指针间隔n向后移动，达到时间复杂度<span class="math inline">\(O(n)\)</span>和空间复杂度<span class="math inline">\(O(1)\)</span>的要求。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next=head;</span><br><span class="line">    ListNode* p=head;</span><br><span class="line">    ListNode* it=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        it=it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(it==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(it!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        dummy=dummy-&gt;next;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        it=it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    dummy-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意：需要考虑删除头结点的情况，不能对所有情况都简单地返回head指针。<p></p><h2 id="两数相加">两数相加</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">【LeetCode 2】Add Two Numbers</a></p><p>依题意，把形如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出: 7 -&gt; 0 -&gt; 8</span><br><span class="line">注解: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>的两数相加。同时应该注意一些边缘条件，如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1:[], l2:[0,1], l1+l2&#x3D;[0,1]</span><br><span class="line">l1:[9,9], l2:[1], l1+l2&#x3D;[0,0,1]</span><br></pre></td></tr></table></figure>我的代码太过复杂，虽然通过了测试，但是仅优于很少的答案。因为我是以while(l1&amp;&amp;l2)作为循环条件，且没有哑结点以简化代码，所以此处贴上LeetCode官方的Java题解<sup>1</sup>，以供参考：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="参考文献">参考文献</h2><p>[1] 作者：LeetCode 链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/" target="_blank" rel="noopener" class="uri">https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/</a> 来源：力扣</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--动规专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E5%8A%A8%E8%A7%84%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Sun Feb 23 2020 16:28:39 GMT+0800 (GMT+08:00) --><h2 id="最大子序列和的动态规划解法">最大子序列和的动态规划解法</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168" target="_blank" rel="noopener">【PAT A1007】Maximum Subsequence Sum</a></p><p>主要思路：dp数组记录最大子序列和，from数组记录以当前位置结束的极大子序列的起始下标。dp数组的递推公式为： <span class="math display">\[ dp[i]=\begin{cases} arr[0]&amp;,\ i=0\\ \max \{ dp[i-1]+arr[i],arr[i] \} &amp;,\ i&gt;0 \end{cases} \]</span> 。而from的递推公式可类比写出。注意到代码编写时有条件“dp[i-1]==0”，实际上这是依具体题目设定确定的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">from[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i<span class="number">-1</span>]+arr[i]&gt;arr[i]||dp[i<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">        from[i]=from[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dp[i]=arr[i];</span><br><span class="line">        from[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxSum&lt;dp[i])&#123;</span><br><span class="line">        maxSum=dp[i];</span><br><span class="line">        maxInd=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--数学专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E6%95%B0%E5%AD%A6%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Sun Feb 23 2020 16:28:39 GMT+0800 (GMT+08:00) --><h2 id="进制转换">进制转换</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344" target="_blank" rel="noopener">【PAT B1022】D进制的A+B</a></p><h3 id="p进制数x转换为十进制数y">P进制数x转换为十进制数y</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> y=<span class="number">0</span>, product=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">    y=y+(x%<span class="number">10</span>)*product;</span><br><span class="line">    x/=<span class="number">10</span>;</span><br><span class="line">    product*=P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将十进制数y转换为q进制数x">将十进制数y转换为Q进制数x</h3><p>注意一定要用<strong>do……while循环</strong>，而非while循环</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">32</span>], num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    z[num]=y%Q;</span><br><span class="line">    ++num;</span><br><span class="line">    y/=Q;</span><br><span class="line">&#125;<span class="keyword">while</span>(y!=<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像处理</title>
    <url>/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<!-- build time:Sun Feb 23 2020 16:28:39 GMT+0800 (GMT+08:00) --><h2 id="关于课程">关于课程</h2><ul><li>教科书：Gonzalez著《数字图像处理》，建议参照英文原版</li><li>辅助教学工具：MATLAB等</li><li>考核方式：<ul><li>三个作业15+15+10=40%</li><li>期末考试60%</li></ul></li></ul><h2 id="基本概念">基本概念</h2><ul><li>研究目的<ul><li>改善图像方便人类解读</li><li>存储传输表示从而帮助机器自动理解</li></ul></li><li>图像：二维函数<span class="math inline">\(f(x,y)\)</span><ul><li>x, y为空间坐标</li><li><span class="math inline">\(f(x,y)\)</span>为<strong>灰度</strong></li></ul></li><li>数字图像<ul><li><span class="math inline">\(x, y, f(x,y)\)</span>均为<strong>离散值</strong></li><li>位置+灰度值组成<strong>像素</strong></li></ul></li><li>数字图像处理<ul><li>借助数字计算机处理数字图像</li></ul></li><li>图像来源：可见光、电磁波谱、超声波、电子显微镜、计算机生成</li><li>区分：数字图像处理、图像分析、计算机视觉<ul><li>低级处理<ul><li>特点：输入、输出均是图像</li><li>去噪、对比度增强、图像锐化</li></ul></li><li>中级处理<ul><li>特点：输入为图像，输出为图像属性</li><li>图像分割、区域描述、物体识别</li></ul></li><li>高级处理<ul><li>特点：理解图像内容/含义、模拟人类视觉</li></ul></li><li>数字图像处理：包括低级处理、中级处理</li><li>图像分析：基本上是物体识别</li><li>计算机视觉：中级、高级处理</li><li>不必执着于界限，大概知道即可</li></ul></li><li>举例：自动文本分析<ul><li>数字图像处理：图像获取、图像预处理、图像分割、区域描述、字符识别</li><li>图像分析、计算机视觉：内容理解</li></ul></li><li>1960s诞生：大型计算机、空间项目</li></ul><h2 id="应用实例">应用实例</h2><ul><li>图像信息源：电磁波谱、声波、电子、计算机<ul><li>电磁波谱<ul><li>伽马射线：核医学、天文观测<ul><li>原理：同位素衰变放出伽马射线</li></ul></li><li>X射线：医学诊断（CT）、工业、天文学</li><li>紫外波段成像：印刷、工业检测、显微镜、天文</li><li>可见光及红外波段成像：显微镜、天文学、遥感、工业、法律实施等</li><li>微波波段成像：雷达</li><li>无线电波成像：医学（核磁共振）、天文学</li></ul></li><li>声波成像：地质勘探、工业、医学</li><li>电子显微镜成像：透射电子显微镜、扫描电子显微镜</li><li>计算机生成图像：分形、三维建模</li></ul></li><li>典型应用：图像检索、动画、游戏制作、美颜、医疗诊断、地球遥感、天气预报、天文观测、安防监控、国防</li></ul><h2 id="基本步骤">基本步骤</h2><ul><li>图像获取<ul><li>从信息源获得图像、离散化、预处理</li></ul></li><li>图像增强<ul><li>适应特定应用、问题相关、是主观的、易于理解（因此以图像增强为背景介绍滤波）</li><li>图像本身没有变差，去主观提升它</li></ul></li><li>图像复原<ul><li>改进图像质量、以图像退化的数学模型为基础、它是客观的</li><li>图像已经变差了，例如图像上有噪声，要把噪声去掉；或者图像变得很小，通过算法计算超分辨率，从而提升图像质量</li></ul></li><li>彩色图像处理<ul><li>彩色模型、彩色处理技术</li></ul></li><li>小波<ul><li>以不同分辨率描述图像、实现数据压缩和金字塔表示</li></ul></li><li>图像压缩<ul><li>压缩图片大小、减少图像存储量或带宽、JPEG、GIF、PNG</li></ul></li><li>形态学处理<ul><li>提取图像分量、用以表示和描述形状、输出开始变成图像的属性</li></ul></li><li>分割<ul><li>将一幅图像划分为它的组成部分、最困难之一、是进一步处理的基础、分割后的结果为边界或区域</li><li>分割结果边界或区域与应用目标有关，要边界存边界，要区域就要把整个区域保存</li></ul></li><li>表示和描述<ul><li>描述分割后的结果、也被称为特征选择</li></ul></li><li>识别<ul><li>给目标赋予标记</li><li>应用：字符识别、指纹识别、人脸识别</li></ul></li><li>知识库<ul><li>蕴含问题本身的先验知识、知识库和模块之间的双向交互、感兴趣区域的位置、物体间的关系</li></ul></li></ul><h2 id="系统构成">系统构成</h2><ul><li>图像处理系统<ul><li>图像传感器：获取图像，如摄像机、B超等</li><li>专用图像处理硬件：数字化器、算术逻辑单元</li><li>计算机：通用计算机、专用计算机等</li><li>图像处理软件：执行特定任务的专用模块、可编程调用</li><li>大容量存储<ul><li>处理图像时短期存储：内存、存储板/帧缓存</li><li>频繁调用的在线存储：硬盘</li><li>不频繁调用的档案存储：磁带、光盘</li></ul></li><li>图像显示器：液晶显示器、投影仪等</li><li>硬拷贝：打印机、胶片</li><li>网络：局域网、互联网实现传输</li></ul></li></ul><h2 id="阅读材料">阅读材料</h2><ul><li>期刊：IJCV, TPAMI, TIP, CVIU, PR</li><li>会议：ICIP, CVPR, ICCV, ECCV</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>大三下</tag>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>模式识别</title>
    <url>/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<!-- build time:Sun Feb 23 2020 16:28:39 GMT+0800 (GMT+08:00) --><h2 id="关于课程">关于课程</h2><ul><li>课程目标：理解、记忆模式识别中的基本概念、步骤和方法<ul><li>对重要方法，要能实际应用，并能理解其<strong>前提条件、应用范围、应用注意事项和方法原理及推导</strong></li><li>对讲授的其他方法，要能理解其含义和使用环境</li><li>要对模式识别的前沿领域有感性的认识</li><li>进一步能够通过独立阅读和实践掌握较深入的问题和方法，能应用到学习、研究中遇到的问题中（作业、考试不做要求）</li></ul></li><li>成绩考核：<ul><li>期末考试50-60%，作业40-50%</li><li>自愿做大作业的本科同学有适当加分（视疫情发展定）</li><li>中英文教材纠错有加分</li></ul></li><li>参考书：<ul><li>DHS/模式分类（第二版）</li><li>PRML</li></ul></li></ul><h2 id="第一章-引言">第一章 引言</h2><h3 id="引言">引言</h3><ul><li>什么是模式识别？<ul><li>PRML的定义：<strong>automatic discovery of regularities</strong> in data ... and with <strong>the use of these regularities</strong> ...</li><li>regularities: 可以是描述的一长串话，也可以是一些标签（即有规律的事物）</li></ul></li><li>模式识别的特征<ul><li>输入：数据(data, input value, ...)</li><li>输出：模式(faces, objects, words, melodies, label, categories, regularity, ...)</li><li>输入转换到输出(automatic, algorithm, assignment, ...)，这是困难的</li></ul></li><li>Autopilot、Kinect、Siri<ul><li>输入？</li><li>输出？</li><li>困难？</li></ul></li><li>输入数据的质量至关重要！（第一遍强调）</li><li>特征：被<strong>使用</strong>的数据或从原始输入数据中<strong>提取的数据</strong></li><li>评估：模式识别系统的输出与真实值比较</li><li>转换：<ul><li>常见方法：机器学习（learning from experience）</li><li>概念<ul><li>训练集：已搜集的数据</li><li>模型：从训练集得到的规律，表现形式<strong>多样</strong></li><li>测试：将这些规律应用到<strong>新</strong>的例子以得到针对该例子的结果（模式识别的输出）</li><li>测试集：为了评估这些规律搜集的数据</li></ul></li><li>对训练集和测试集的要求：交集为空</li></ul></li><li>模式识别的步骤（重要）<ul><li><strong>获取数据<span class="math inline">\(\rightarrow\)</span>提取特征<span class="math inline">\(\rightarrow\)</span>进行学习<span class="math inline">\(\rightarrow\)</span>评价评估<span class="math inline">\(\rightarrow\)</span>实际应用<span class="math inline">\(\rightarrow\)</span>获取数据</strong><ul><li>深度学习是把“提取特征”和“进行学习”合二为一<ul><li>深度学习成功的关键是提取很好的特征——表征学习</li></ul></li></ul></li><li>需要<strong>多次</strong>反馈（feedback）、尝试、修改</li><li>什么步骤最重要：<ul><li>总体来说，看情况</li><li>个人角度出发，提取特征是最重要的</li></ul></li></ul></li><li>模式识别为什么困难？<ul><li>见教材第三章</li></ul></li><li>模式识别和机器学习的区别（重要）<ul><li>模式识别：数据获取（质量高），不关注机器学习算法的理论保证，更具系统性</li><li>机器学习：假设数据符合数学、统计上的性质或约束，关注机器学习算法的理论保证</li></ul></li></ul><h3 id="进一步阅读">进一步阅读</h3><ul><li>各相关领域的最新进展可以参考其重要会议和期刊<ul><li>机器学习：JMLR,ICML,NIPS</li><li>计算机视觉：TPAMI,IJCV,CVPR,ICCV,ECCV</li><li>多媒体：ACM Multimedia, TMM</li></ul></li><li>有用的资源：<ul><li>计算机视觉、图像处理OpenCV：http://opencv.org/</li><li>Matlab：若干工具箱toolbox</li><li>深度学习软件包（百花齐放）！</li></ul></li></ul><h2 id="第二章-数学基础">第二章 数学基础</h2><p><em>此处仅列出自己不熟悉的和老师强调的内容</em></p><h3 id="线性代数与矩阵论">线性代数与矩阵论</h3><ul><li>柯西-施瓦茨不等式<ul><li>柯西不等式：<span class="math inline">\((\Sigma_{k=1}^na_kb_k)^2\leq (\Sigma_{k=1}^na_k^2)(\Sigma_{k=1}^nb_k^2)\)</span>，等号成立当且仅当<span class="math inline">\(\exists c\in \mathbb{R},\ \forall k,\ a_k=cb_k.\)</span></li><li>施瓦茨不等式：<span class="math inline">\([\int_a^bf(x)g(x)dx]^2\leq \int_a^b[f(x)]^2dx\cdot\int_a^b[f(x)]^2dx\)</span>，等号成立当且仅当<span class="math inline">\(\exists c\in \mathbb{R},\ \forall x\in [a, b],\ f(x)=cg(x).\)</span>（此处若用测度论解释则不准确）</li></ul></li><li>向量（vector）不加特殊说明时，我们认为它是一个列向量</li><li>注意：特征(feature)<span class="math inline">\(\neq\)</span>特征值(eigenvalue)/特征向量(eigenvector)</li><li>方阵的迹(trace)：<span class="math inline">\(tr(AB)=tr(BA),\ tr(ABC)=tr(BCA),\ \dots\)</span></li><li><strong>实对称矩阵</strong>：最经常用到，例如<span class="math inline">\(XX^T,\ X^TX\)</span>均为实对称矩阵，特征有：<ul><li>所有特征值都是实数，特征向量都是实向量</li><li>特征向量互相垂直：<span class="math inline">\(\xi_i^T\xi_j=0\ (i\neq j)\)</span></li><li><span class="math inline">\(E=[\xi_1\ \xi_2\ \dots\ \xi_n]\)</span>是<span class="math inline">\(n\times n\)</span>的满秩方阵，<span class="math inline">\(rank(E)=n\)</span></li></ul></li><li><strong>实对称矩阵的分解</strong>（不熟悉！）<ul><li>谱分解：<span class="math inline">\(X=\Sigma_{i=1}^n\lambda_i\xi_i\xi_i^T\)</span>（<span class="math inline">\(n\times n\)</span>矩阵，外积），<span class="math inline">\(n\)</span>个<span class="math inline">\(n\times n\)</span>的秩为1的矩阵由<span class="math inline">\(\lambda_i\)</span>加权后求和可以得到<span class="math inline">\(X\)</span>.</li><li>约定<span class="math inline">\(\|\xi_i\|=1\)</span>，则<span class="math inline">\(E\)</span>为正交矩阵</li><li><span class="math inline">\(X=E\Lambda E^T\)</span><ul><li><span class="math inline">\(\Lambda\)</span>是一个对角矩阵，<span class="math inline">\(\Lambda_{ii}=\lambda_i\)</span></li><li><span class="math inline">\(EE^T=E^TE=I,\ E^{-1}=E^T,\ |E|=1.\)</span></li></ul></li></ul></li><li>正定、半正定（本课只考虑对称的情况）<ul><li>二次型：<span class="math inline">\(x^TAx\in \mathbb{R}\)</span>，经常用到</li></ul></li><li>矩阵求导：假设导数都存在，要学会查表并合理应用<ul><li><span class="math inline">\((\dfrac{\partial \boldsymbol{a}}{\partial \boldsymbol{x}})_{ij}=\dfrac{\partial a_i}{\partial x_j}\)</span>，即Hessian矩阵.</li><li>例如<span class="math inline">\(f(\boldsymbol{a})=\boldsymbol{a}^T\boldsymbol{x}\)</span>，则<span class="math inline">\(\dfrac{\partial f}{\partial \boldsymbol{a}}=\boldsymbol{x}\)</span></li></ul></li></ul><h3 id="概率论">概率论</h3><ul><li>离散情况下概率质量函数(pmf)的概率满足<span class="math inline">\(0\leq p(x)\leq 1\)</span>；连续情况下概率密度函数(pdf)的概率满足<span class="math inline">\(p(x)\geq 0\)</span>，即可以大于<span class="math inline">\(1\)</span>.</li><li><strong>条件分布</strong>：<span class="math inline">\(P(X=x|Y=y)\)</span>：教材常用<ul><li>例如：<span class="math inline">\(Y\)</span>作为input，<span class="math inline">\(X\)</span>作为output</li></ul></li><li>期望<span class="math inline">\(E[f(x)]\)</span>：如果分布<span class="math inline">\(p(x)\)</span>及函数<span class="math inline">\(f(x)\)</span>确定，那么求出的期望是确定的，不包含随机性；<ul><li>注意：如果<span class="math inline">\(f(x,y)\)</span>仅确定<span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>不确定，那么求出的期望仍为随机变量</li></ul></li><li>*条件期望：<span class="math inline">\(E(f(\boldsymbol{x})|Y=\boldsymbol{y})=\Sigma_\boldsymbol{x}f(\boldsymbol{x})\cdot p(\boldsymbol{x}|\boldsymbol{y})\)</span></li><li>方差<ul><li><span class="math inline">\(Var(X)=E[(X-EX)^2]=E(X^2)-(EX)^2\)</span></li><li>向量形式：<span class="math inline">\(Var(X)=E[(X-EX)(X-EX)^T]\)</span>（自己和自己作外积）</li></ul></li><li>当<span class="math inline">\(p(x)\)</span>确定即随机变量分布确定，且<span class="math inline">\(f(x)\)</span>已知的情况下<ul><li>期望、方差是一个确定的数/向量/矩阵</li><li>注意：<span class="math inline">\(g(y)=E(X|Y=y)\)</span>是对<span class="math inline">\(x\)</span>求积分或求和，因此<span class="math inline">\(g(y)\)</span>与<span class="math inline">\(X\)</span>无关，是一个确定的关于<span class="math inline">\(y\)</span>的函数</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>模式识别</category>
      </categories>
      <tags>
        <tag>大三下</tag>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title>写在一周年</title>
    <url>/%E9%82%A3%E4%B8%80%E5%B9%B4/%E5%86%99%E5%9C%A8%E4%B8%80%E5%91%A8%E5%B9%B4/</url>
    <content><![CDATA[<!-- build time:Sun Feb 23 2020 16:28:39 GMT+0800 (GMT+08:00) --><p><em>这是2019年12月1日的推送，首发于公众号“酸辣目鱼汤”。虽然作者是我，但是编辑是她。我想将文章转载于此，暂托因新型冠状病毒肺炎疫情而不得见面的遗憾。</em></p><p><br></p><center>0</center><p><br></p><p>这是我在南京大学第三个冬天了。去年这个时候，我结交了一个人，她19岁。</p><p>我很害怕，害怕认识别人。自主招生为学弟学妹家长答疑的那个下午，我早早来到了教室，低着头，找到一个后排的座位躲了起来。“嗨！”她对我说。“嗨。”我怯生生地，心里想着这是谁呢？</p><p>福建同乡群里，她说明天回家，可是箱子好重。在食堂的我顿时陷入“茶饭不思”的状态。一个小时以后，我对自己说：这可能是一个改变你未来的决定。“我能帮你提箱子吗？”实话说，那时候的我多么希望你断然拒绝，终结我的一切念想。“好！”你说。这真是一个超纲题。</p><p><br></p><center>1</center><p><br></p><p>那个暑假很漫长，漫长得我对未来感到很绝望：要是被别人表白了怎么办，我是不是就没有机会了？我知道你的生日是9月5日，我买了你心心念念的礼物，在礼物的夹层里塞了我誊写了好几遍的情书。我把情书拿出来，又塞进去，拿出来再添了两个字，又塞进去压好——那是我一年多来写字写得最认真的时候了。</p><p>像《一千零一夜》，我把“早安”和“晚安”换着31*2=62种互不相同的方法在每个早上醒来之后和晚上睡去之前和你说。你也会回我——通常是晚上11点和中午11点。那个暑假，我要在早上8点起床和11点之间每一会儿就打开手机看看你有没有回我。有的时候，明明知道你11点才起床，但你那么久不回，我仍然会感到难过。</p><p><br></p><center>2</center><p><br></p><p>新学期每个周末的早上，我会如约等候在你的宿舍楼下，一边想着你今天会穿什么样的衣服，会梳什么样的头发，一边看着时间超过1分钟，2分钟……或许这就是可爱吧。</p><p>我们订了12月1日晚上的江苏大剧院的《戏台》。回去的路上，路程很漫长，空空荡荡的车厢外，繁星很美好。</p><p>那天晚上，我写道“其实你好多好多瞬间都可爱到我了……比如说吃东西吃着吃着嘴角就有酸奶的沫沫或者小粒的米饭、转头看我的时候黑色眼眸的扑朔迷离、夜晚地上你的晃头晃脑的影子，还有捋左边一小撮头发时候歪斜着头的模样，喝完酸奶把吸管咬得扁扁的折来折去……”</p><p><br></p><center>3</center><p><br></p><p>我发现我已经逐渐开始过起了无法脱离你的生活，一个人去食堂的时候想拿两个盘子，走在路上的时候感觉手上少提了什么，在图书馆的时候老是看看隔壁有没有你的影子，坐在地铁上，左边和右边却都是不认识的人。</p><p>有的时候未来真是一种很玄幻的东西，我们也早早开始为彼此的未来考虑、尝试去做出决定。我很爱你，我希望能够给你安稳幸福。不要离你太远，要常伴身边。要你时时快乐，要你活泼天真。可就算到了要和所有记忆握手言和的时候，我也希望你能够活在时间里，没有烟火气，笑靥如花。</p><p>或许不久之后再回来看这些文字，我还是会说自己不解风情吧。</p><p><br></p><center>4</center><p><br></p><p>最后，建议用Python运行如下神秘代码：</p>print('<!-- rebuild by neat -->]]></content>
      <categories>
        <category>那一年</category>
      </categories>
      <tags>
        <tag>那一年</tag>
      </tags>
  </entry>
  <entry>
    <title>建站撒花</title>
    <url>/%E7%AB%99%E5%8A%A1/%E5%BB%BA%E7%AB%99%E6%92%92%E8%8A%B1/</url>
    <content><![CDATA[<!-- build time:Sun Feb 23 2020 16:28:39 GMT+0800 (GMT+08:00) --><p>欢迎来到我的小站！这是我的个人博客，您可以在这里看到我的日常生活或技术总结。我将不定时对我的博客进行更新。</p><p>如果您对我的博客感兴趣，可以打赏或者向朋友分享！如果想要与我深入交流，请给我发邮件：<a href="mailto:njulh2017@outlook.com">njulh2017@outlook.com</a>，或者访问我的个人主页：<a href="https://lajioj.github.io/haol/" class="uri">https://lajioj.github.io/haol/</a>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>站务</category>
      </categories>
      <tags>
        <tag>站务</tag>
      </tags>
  </entry>
</search>
