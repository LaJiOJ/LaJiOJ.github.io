<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>机试知识点--树专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Mon Mar 23 2020 15:43:25 GMT+0800 (GMT+08:00) --><h1 id="二叉搜索树">二叉搜索树</h1><h2 id="独立的二叉搜索树有几个">独立的二叉搜索树有几个</h2><p>题目链接：<a href="https://pic.leetcode-cn.com/fe9fb329250b328bb66032dda25b867e0047fcb480c2c0bcf14ecc2a4c12e454-image.png" target="_blank" rel="noopener">【LeetCode 96】Unique Binary Search Trees</a></p><p>这是一个组合计数问题，其实可以归约到卡特兰数问题。<img src="https://pic.leetcode-cn.com/fe9fb329250b328bb66032dda25b867e0047fcb480c2c0bcf14ecc2a4c12e454-image.png" alt="题图"></p><p>根据LeetCode官方的图解可知，卡特兰数问题就是中间选一个作为根节点，然后把两边的卡特兰数集合作笛卡尔积，求势可得<span class="math inline">\(F[i]=G[i-1]G[n-i]\)</span>。把所有这样的<span class="math inline">\(F[i]\)</span>求和即可得到卡特兰数。因此卡特兰数的动规方程是： <span class="math display">\[ G[i]=\begin{cases} 1&amp;,\ i=0,\ 1\\ G(0)G(n-1)+G(1)G(n-2)+\dots+G(n-1)G(0)&amp;,\ i\geq 2 \end{cases} \]</span> 递推公式是： <span class="math display">\[ G[0]=1,\ G[n+1]=\dfrac{2(2n+1)}{n+2}G[n] \]</span> 通项公式是： <span class="math display">\[ G[n]=\dfrac{\dbinom{2n}{n}}{n+1} \]</span> 还有很多同类组合计数问题也可以直接用卡特兰数求解，包括：</p><ul><li>进出栈问题：一个足够大的栈的进栈序列为<span class="math inline">\(1,2,3,⋯,n\)</span>时有多少个不同的出栈序列？</li><li>二叉树构成问题：有<span class="math inline">\(n\)</span>个结点，问总共能构成几种不同的二叉树？</li><li>凸多边形的三角形划分：一个凸的<span class="math inline">\(n\)</span>边形，用直线连接他的两个顶点使之分成多个三角形，每条直线不能相交，问一共有多少种划分方案？</li><li>有n+1个叶子的满二叉树的个数？（提示：向左记为+1，向右记为−1，按照向左优先的原则，从根节点开始遍历）</li><li>在n*n的格子中，只在下三角行走，每次横或竖走一格，有多少中走法？（提示：横进栈竖出栈，本质上也是卡特兰数问题）</li><li>由nn对括号形成的合法括号表达式的个数？</li><li>等等</li></ul><p>卡特兰数动规解法如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *cat=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>]();</span><br><span class="line">cat[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">cat[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>,k=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=i<span class="number">-1</span>&amp;&amp;k&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        cat[i]+=(cat[j]*cat[k]);</span><br><span class="line">        ++j;</span><br><span class="line">        --k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>卡特兰数更加便于计算的递推公式解法如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> C=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">    C=C*<span class="number">2</span>*(<span class="number">2</span>*i+<span class="number">1</span>)/(i+<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意为了防止分子的<span class="math inline">\(C\)</span>溢出，即使最后返回int型，也要用long型计算。<p></p><h2 id="独立的二叉搜索树有几个进阶版">独立的二叉搜索树有几个——进阶版</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">【LeetCode 95】Unique Binary Search Trees II</a></p><p>这题是上一题的进阶版，题目要求输出所有可能的序列。此处考虑分治算法，对任意的<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>，可以以<span class="math inline">\(i\)</span>为根节点遍历之，每次取<span class="math inline">\(1\)</span>到<span class="math inline">\(i-1\)</span>和<span class="math inline">\(i+1\)</span>到<span class="math inline">\(n\)</span>分治求所有可能的组合即可。</p><p>另外，这一题存在一些边缘情况应该考虑清楚，例如start&gt;end，n=0等。参考源码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; forRobust;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> forRobust;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> divideConquer(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">divideConquer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; start,<span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt;ans;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;<span class="built_in">end</span>)&#123;</span><br><span class="line">        ans.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=<span class="built_in">end</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt;leftSubTree=divideConquer(start,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt;rightSubTree=divideConquer(i+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;leftSubTree.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;rightSubTree.<span class="built_in">size</span>();++k)&#123;</span><br><span class="line">                TreeNode* thisRoot=<span class="keyword">new</span> TreeNode(i);<span class="comment">//注意这里应该new一个i来push到ans中</span></span><br><span class="line">                thisRoot-&gt;left=leftSubTree[j];</span><br><span class="line">                thisRoot-&gt;right=rightSubTree[k];</span><br><span class="line">                ans.push_back(thisRoot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效的二叉搜索树">有效的二叉搜索树</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">【LeetCode 98】Validate Binary Search Tree</a></p><p>题目的意思是判断一个二叉搜索树是否满足下列条件： - 一个结点的左子树只包含值比当前结点的值<strong>小</strong>的结点 - 一个结点的右子树只包含值比当前结点的值<strong>大</strong>的结点 - 左子树和右子树必须也是有效的二叉搜索树</p><p>有两种解决思路，一种是根据定义递归，每次遇到一个新结点便划分区间，然后判断子树是否在划分的区间内即可；另一种思路是把树表示成中序遍历的形式，根据定义易知此时遍历序列为升序序列即可。</p><p>第一种思路的代码如下，注意用到long long型是因为如果测试样例存在2147483647的话划分区间会出问题而返回false。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myJudge(root,<span class="built_in">min</span>,<span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">myJudge</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> left,<span class="keyword">long</span> <span class="keyword">long</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;=left||root-&gt;val&gt;=right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myJudge(root-&gt;left,left,root-&gt;val)</span><br><span class="line">            &amp;&amp;myJudge(root-&gt;right,root-&gt;val,right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">min</span>=<span class="number">-9223372036854775808</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">max</span>=<span class="number">9223372036854775807</span>;</span><br></pre></td></tr></table></figure><p></p><p>第二种思路的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TraverseBST(root);</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vec.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i<span class="number">-1</span>]&gt;=vec[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TraverseBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TraverseBST(root-&gt;left);</span><br><span class="line">        vec.push_back(root-&gt;val);</span><br><span class="line">        TraverseBST(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec;</span><br></pre></td></tr></table></figure><p></p><h2 id="树的同构">树的同构</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/1211841066264109056/problems/1234055373040824320" target="_blank" rel="noopener">【PAT 03】树的同构</a></p><p>题目意思是：给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。有一种暴力的思路是枚举所有可能的互换结果，还有一种剪枝策略可以大大缩小解空间：T1和T2同构当且仅当两个树的同一个结点的(左子树与右子树均分别相同)或(T1的左子树等于T2的右子树且T1的右子树等于T2的左子树)。</p><p>这一题还有一个小trick，就是它的两棵树的结点信息如下给出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">A <span class="number">1</span> <span class="number">2</span></span><br><span class="line">B <span class="number">3</span> <span class="number">4</span></span><br><span class="line">C <span class="number">5</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">6</span> -</span><br><span class="line">G <span class="number">7</span> -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">G - <span class="number">4</span></span><br><span class="line">B <span class="number">7</span> <span class="number">6</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">5</span> <span class="number">1</span></span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">2</span> -</span><br></pre></td></tr></table></figure>对应的树为<img src="https://images.ptausercontent.com/28" alt="题图">也即列举的第一个结点完全可以不是树的根节点。为了解决这个问题，我们首先要用结构数组来储存树的信息，继而观察可以知道<strong>没有出现</strong>在左右子节点的数字即为根节点的数组下标，上面的两棵树的数组下标即为0和3，对应结点都为A。<p></p><p>另外有一个坑点是数据结构小白教程里面输入数据的读法有问题，用scanf(&quot;%c&quot;)的类似形式来读会出现偏差，最后用cin才把输入数据读好的——这启示我如果以后遇到读char类型的题目，搞不清楚还是尽量用cin。</p><p>最后可以写出代码，此处就不贴出了。</p><h2 id="前序和中序建立树">前序和中序建立树</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">【LeetCode 105】从前序与中序遍历序列构造二叉树</a></p><p>题目意思很简单，即从给出的前序和中序遍历序列构造一棵树，这是数据结构的基本问题，直接贴上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inorder.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder,<span class="number">0</span>,inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">const</span> <span class="keyword">int</span>&amp; prel, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">const</span> <span class="keyword">int</span>&amp; inl, <span class="keyword">const</span> <span class="keyword">int</span>&amp; inr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prel&gt;=preorder.<span class="built_in">size</span>()||inl&gt;inr)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* p=<span class="keyword">new</span> TreeNode(preorder[prel]);</span><br><span class="line">    <span class="keyword">if</span>(inl==inr)&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=inl;i&lt;=inr;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i]==preorder[prel])&#123;</span><br><span class="line">            p-&gt;left=build(preorder,prel+<span class="number">1</span>,inorder,inl,i<span class="number">-1</span>);</span><br><span class="line">            p-&gt;right=build(preorder,prel+i-inl+<span class="number">1</span>,inorder,i+<span class="number">1</span>,inr);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是p-&gt;right这条语句中对preorder数组传入的偏移量应该为prel+i-inl+1。</p><h1 id="树易错知识点回顾">树易错知识点回顾</h1><h2 id="树">树</h2><ul><li>结点的度：该结点的子树个数</li><li>树的表示方法：儿子-兄弟表示法，一个指针指儿子，另一个指针指同层兄弟</li></ul><h2 id="二叉树">二叉树</h2><ul><li>n个结点的判定树深度为<span class="math inline">\(\lfloor log_2n\rfloor+1\)</span></li><li>11个结点的判定树查找的平均成功查找次数<span class="math inline">\(ASL=(4\times 4+4\times 3+2\times 2+1)/11=3\)</span></li><li>对任何非空二叉树T，若<span class="math inline">\(n_0\)</span>表示叶节点的个数，<span class="math inline">\(n_2\)</span>是度为2的非叶节点个数，那么两者满足<span class="math inline">\(n_0=n_2+1\)</span><ul><li>由总结点数-1=总边数，即<span class="math inline">\(n_0+n_1+n_2-1=0\times n_0+1\times n_1+2\times n_2\)</span>可证得该结论</li></ul></li><li>数组实现的二叉树存储：<ul><li>非根节点的的父节点序号是<span class="math inline">\(\lfloor i/2\rfloor\)</span>；</li><li>结点<span class="math inline">\(i\)</span>的左孩子的结点序号是<span class="math inline">\(2i, 2i\leq n\)</span>；</li><li>结点<span class="math inline">\(i\)</span>的右孩子的结点序号是<span class="math inline">\(2i+1, 2i+1\leq n\)</span>.</li></ul></li><li>中序遍历的非递归算法：使用堆栈，先序类似；层序遍历：队列<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 遇到一个结点，压栈并遍历左子树</span><br><span class="line">2. 左子树遍历结束后从栈顶弹出并访问这个结点</span><br><span class="line">3. 然后中序遍历右子树</span><br></pre></td></tr></table></figure></li><li>求二叉树的高度：左右子树高度求出后才能求当前结点高度，因此改造后序遍历算法即可</li><li>中序遍历输出中缀表达式：存在运算符优先级的问题，如何解决？<ul><li>输出左子树的时候先输出一个左括号，左子树结束的时候加入右括号</li></ul></li><li>前序后序能否确定一个唯一的二叉树？不能</li></ul><h2 id="平衡二叉树">平衡二叉树</h2><ul><li>设<span class="math inline">\(n_h\)</span>是高度为<span class="math inline">\(h\)</span>的平衡二叉树的最小结点数，则<span class="math inline">\(n_0=1, n_1=2, n_2=4, n_3=7, \cdots, n_h=n_{h-1}+n_{h-2}+1\)</span></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--线性表专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Mon Mar 23 2020 15:43:25 GMT+0800 (GMT+08:00) --><h1 id="数组">数组</h1><h2 id="盛最多水的容器">盛最多水的容器</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">【LeetCode】盛最多水的容器</a></p><p>题目意思就是找到如下图所示最大的面积<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="题图">，挑战性在于希望在<span class="math inline">\(O(n)\)</span>时间复杂度内完成查找。</p><p>我的思路是使用两个指针分别指向头尾两个高度，让指向较短线段的指针向另外一个指针移动。因为移动较短线段的指针会得到一条相对较长的线段，这可以克服由宽度减小而引起的面积减小。反之则必然引起面积缩小。C++代码实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> delta=last-prev;</span><br><span class="line">    <span class="keyword">int</span> maxArea=<span class="built_in">min</span>(<span class="built_in">height</span>[prev],<span class="built_in">height</span>[last])*delta;</span><br><span class="line">    <span class="keyword">int</span> tempArea=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(delta)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height</span>[prev]&lt;=<span class="built_in">height</span>[last])&#123;</span><br><span class="line">            ++prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            --last;</span><br><span class="line">        &#125;</span><br><span class="line">        --delta;</span><br><span class="line">        tempArea=<span class="built_in">min</span>(<span class="built_in">height</span>[prev],<span class="built_in">height</span>[last])*delta;</span><br><span class="line">        maxArea=(tempArea&gt;maxArea)?tempArea:maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意到这里面用了一些涉及到编译和汇编的小trick提升了执行速度，提交界面显示执行时间超过90.70%的用户。</p><h2 id="pat-ranking">PAT Ranking</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805474338127872" target="_blank" rel="noopener">【PAT A1025】PAT Ranking</a></p><p>题目主要考察的就是模拟一个有优先级的排序算法，编写程序的过程中发现自己两点不足：</p><ol type="1"><li>cmp函数编写不熟练；</li><li>题目要求“the registration number (a 13-digit number)”，表明肯定不能直接使用int类型变量记录准考证号，应该考虑使用char字符数组记录。</li><li>vector使用不熟练，注意初始化n行元素类型为Info的二维数组应该用语句<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Info&gt;&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p>下面把cmp函数代码贴出，供以后复习参考：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Info &amp;a,<span class="keyword">const</span> Info &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score==b.score)&#123;</span><br><span class="line">        <span class="comment">//Sort by regNum in a non-decreasing </span></span><br><span class="line">        <span class="comment">//order if the scores are the same.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.regNum,b.regNum)&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="链表">链表</h1><p><em>昨天晚上临睡前突然想到反转链表的操作自己不太熟悉，然后2019年冬季PAT考试刚好考了每k个结点为一组反转链表的题目，而自己却不太会做。因此想要着手撰写这个专题，辅以LeetCode评判系统测试正确性，用以复习链表操作。</em></p><h2 id="反转链表">反转链表</h2><h3 id="反转整个链表">反转整个链表</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">【LeetCode 206】Reverse Linked List</a></p><p>题目的意思直接明了，挑战性在于要一次遍历完链表且不消耗过多的额外空间。这里主要采用三指针迭代的方式求解。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *prev=<span class="literal">NULL</span>;</span><br><span class="line">    ListNode *curr=head;</span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        ListNode *nextTemp=curr-&gt;next;</span><br><span class="line">        curr-&gt;next=prev;</span><br><span class="line">        prev=curr;</span><br><span class="line">        curr=nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="每k个结点为一组反转链表">每k个结点为一组反转链表</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">【LeetCode 25】Reverse Nodes in k-Group</a></p><p>题目的挑战性在于一次遍历就要完成每k个结点反转链表，并且只允许常数级别的额外空间。这里主要采用尾插法解题：即每次遍历到第k个结点，将该组头节点插入第k个结点后面，再将新的该组头节点插入第k个结点后面，以此类推。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* temp=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    temp-&gt;next=head;</span><br><span class="line">    ListNode* grpHead=temp;</span><br><span class="line">    ListNode* grpTail=temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(grpTail!=<span class="literal">NULL</span>&amp;&amp;count&lt;k)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">            grpTail=grpTail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grpTail==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tempHead=grpHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(grpHead-&gt;next!=grpTail)&#123;</span><br><span class="line">            ListNode *curNode=grpHead-&gt;next;</span><br><span class="line">            grpHead-&gt;next=curNode-&gt;next;</span><br><span class="line">            curNode-&gt;next=grpTail-&gt;next;</span><br><span class="line">            grpTail-&gt;next=curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        grpHead=tempHead;</span><br><span class="line">        grpTail=tempHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="移去链表末尾的第n个结点">移去链表末尾的第n个结点</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">【LeetCode 19】Remove Nth Node From End of List</a></p><p>题目意思是移除单向链表的倒数第n个结点，要求遍历一次就可以移除。这里的基本思路是双指针间隔n向后移动，达到时间复杂度<span class="math inline">\(O(n)\)</span>和空间复杂度<span class="math inline">\(O(1)\)</span>的要求。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next=head;</span><br><span class="line">    ListNode* p=head;</span><br><span class="line">    ListNode* it=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        it=it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(it==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(it!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        dummy=dummy-&gt;next;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        it=it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    dummy-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意：需要考虑删除头结点的情况，不能对所有情况都简单地返回head指针。<p></p><h2 id="两数相加">两数相加</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">【LeetCode 2】Add Two Numbers</a></p><p>依题意，把形如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出: 7 -&gt; 0 -&gt; 8</span><br><span class="line">注解: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>的两数相加。同时应该注意一些边缘条件，如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1:[], l2:[0,1], l1+l2&#x3D;[0,1]</span><br><span class="line">l1:[9,9], l2:[1], l1+l2&#x3D;[0,0,1]</span><br></pre></td></tr></table></figure>我的代码太过复杂，虽然通过了测试，但是仅优于很少的答案。因为我是以while(l1&amp;&amp;l2)作为循环条件，且没有哑结点以简化代码，所以此处贴上LeetCode官方的Java题解<sup>1</sup>，以供参考：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="队列的最大值">队列的最大值</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">【LeetCode 面试题59】队列的最大值</a></p><p>题目需要在队列的<span class="math inline">\(O(1)\)</span>时间复杂度进队出队的基础上实现一个<span class="math inline">\(O(1)\)</span>时间复杂度的求最大值操作。注意这里首先不能用优先队列（堆）实现，因为堆实现的队列出队的元素一定是最大元素，而这里要求的是按照正常的队列顺序出队。</p><p>考虑一个双端队列和一个队列，双端队列负责维护一个单调递减的队列，其队头即为当前队列内最大元素。每当进队一个元素时，如果双端队列前的元素比它小就从尾部出队，来保持双端队列的单调递减性质。同时，另外一个正常的队列负责维护所有元素。当需要出队元素时，首先检查双端队列的队头是否和正常队列队头相同，再判断需要两个队列都出队还是只要让正常队列出队。</p><p>实现代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxQueue() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(que.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deq.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(deq.empty()==<span class="literal">false</span>&amp;&amp;deq.back()&lt;value)&#123;</span><br><span class="line">            deq.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        deq.push_back(value);</span><br><span class="line">        que.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(que.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(que.front()==deq.front())&#123;</span><br><span class="line">            deq.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="括号的分数栈实现">括号的分数（栈实现）</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/score-of-parentheses/" target="_blank" rel="noopener">【LeetCode 856】括号的分数</a></p><p>题意为给定一个合法括号串，按规则计算括号的得分，其中()得1分，()()得1+1=2分，(())得1*2=2分，以此类推。代码主要考虑栈的实现，规则如下：</p><ol type="1"><li>每遇到一个左括号，向栈中压入-1；</li><li>每遇到一个右括号，且栈顶为-1，表明此时出现&quot;()&quot;，应该记1分，将栈顶的-1更改为1分</li><li>每遇到一个右括号，且栈顶不为-1，表明此时开始循环，将栈顶得分全部加起来得到temp，直到遇到-1停止，然后把temp*2赋值给当前栈顶替换-1</li><li>循环往复，直到遍历完括号串，此时把栈中所有元素相加返回即为结果。</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz=str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;sta;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;sz)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'('</span>)&#123;</span><br><span class="line">            sta.push(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sta.top()==<span class="number">-1</span>)&#123;</span><br><span class="line">            sta.pop();</span><br><span class="line">            sta.push(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(sta.top()!=<span class="number">-1</span>)&#123;</span><br><span class="line">                temp+=sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            sta.pop();</span><br><span class="line">            sta.push(temp*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sta.empty()==<span class="literal">false</span>)&#123;</span><br><span class="line">        res+=sta.top();</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="线性表易错点回顾">线性表易错点回顾</h1><ul><li>数组中间位置的<strong>插入</strong>应该<strong>从数组尾往前</strong>调整元素，中间位置<strong>删除</strong>应该<strong>从删除位置往后</strong>调整元素</li><li>若用一个数组模拟两个栈，那么应该让数组的<strong>头尾</strong>作为两个栈的栈底使得数组的利用率最大</li><li>若用链表模拟栈，<strong>链表头可以作为栈顶</strong>，但是<strong>链表尾不应该作为栈顶</strong>，因为弹栈时难以维护链表尾（即新的栈顶）；同样地，若用链表模拟队列，同样<strong>不能用链表尾作为队列头</strong>，只能用<strong>链表头作为队列头，链表尾作为队列尾</strong>（队列头只删除而队列尾只插入）</li><li>多重链表的指针域有多个，但是一个结点有多个指针<strong>不一定是多重链表</strong>，如双向链表</li><li>在矩阵的多重链表表示中，第i行的head和第i列的head实际上是<strong>同一个结点</strong></li><li><p>稀疏矩阵用十字链表解决的基本数据结构，注意到tag=0时表示Head结点，用Node* next域，否则tag=1时表示Term结点，用int value域</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    Node* Down;</span><br><span class="line">    <span class="keyword">union</span> URegion&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node* next;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li>中缀转后缀？注意左括号在<strong>栈外优先级最高</strong>，但是在<strong>栈内优先级最低</strong>（因为优先级比栈顶大则压栈，否则弹栈）</li><li>数组实现的环状队列判定队列满的方法？使用n-1个数组空间，即<ul><li>入队时判定队列满：(rear+1)%maxSize==front</li><li>出队时判定队列空：front==rear</li></ul></li></ul><h2 id="参考文献">参考文献</h2><p>[1] 作者：LeetCode 链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/" target="_blank" rel="noopener" class="uri">https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/</a> 来源：力扣</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--动规专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E5%8A%A8%E8%A7%84%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Mon Mar 23 2020 15:43:24 GMT+0800 (GMT+08:00) --><h2 id="子序列系列">子序列系列</h2><h2 id="最大子序列和的动态规划解法">最大子序列和的动态规划解法</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168" target="_blank" rel="noopener">【PAT A1007】Maximum Subsequence Sum</a></p><p>主要思路：dp数组记录最大子序列和，from数组记录以当前位置结束的极大子序列的起始下标。dp数组的递推公式为： <span class="math display">\[ dp[i]=\begin{cases} arr[0]&amp;,\ i=0\\ \max \{ dp[i-1]+arr[i],arr[i] \} &amp;,\ i&gt;0 \end{cases} \]</span> 。而from的递推公式可类比写出。注意到代码编写时有条件“dp[i-1]==0”，实际上这是依具体题目设定确定的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">from[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i<span class="number">-1</span>]+arr[i]&gt;arr[i]||dp[i<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">        from[i]=from[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dp[i]=arr[i];</span><br><span class="line">        from[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxSum&lt;dp[i])&#123;</span><br><span class="line">        maxSum=dp[i];</span><br><span class="line">        maxInd=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="最长上升子序列">最长上升子序列</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">【LeetCode 300】最长上升子序列</a></p><p>题意是给出一个最长上升子序列的长度，要求时间复杂度为<span class="math inline">\(O(n^2)\)</span>，考虑动态规划，有状态转移方程 <span class="math display">\[ dp[i]=\begin{cases} 1&amp;,\ i=0\\ \max \{ dp[i],dp[j]+1 \} &amp;,\ i&gt;0 \text{ and } 0\leq j&lt; i \end{cases} \]</span></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> *dp=<span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">    <span class="keyword">int</span> max_len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;++i)&#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max_len=<span class="built_in">max</span>(dp[i],max_len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[]dp;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>但是好像有一个进阶思考是把时间复杂度降到<span class="math inline">\(O(n\log n)\)</span>，稍微解释一下：思路是维护一个递增数组d，如果当前数比数组所有数都大则加入数组d末尾，否则二分查找<span class="math inline">\(nums[j]\)</span>，使得<span class="math inline">\(d[i−1]&lt;nums[j]&lt;d[i]\)</span>，并更新<span class="math inline">\(d[i]=\textit{nums}[j]\)</span>，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(sz&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *dp=<span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sz;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;dp[len])&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            dp[len]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>,right=len;</span><br><span class="line">            <span class="keyword">int</span> mid,pos=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[mid] &lt; nums[i]) &#123;</span><br><span class="line">                    pos = mid;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[pos+<span class="number">1</span>]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []dp;</span><br><span class="line">    <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="零钱兑换系列">零钱兑换系列</h2><h3 id="零钱兑换">零钱兑换</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">【LeetCode 322】零钱兑换</a></p><p>题目意思是给定一个无线给定不同面额的硬币coins和一个总金额amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。</p><p>主要考虑动态规划的解法，用dp数组记录i元所需的找零数目，状态转移方程为： <span class="math display">\[ dp[i]=\begin{cases} 0&amp;,\ i=0\\ \min \{ dp[i-coins[j]]+1,\ \text{INT\_MAX} \} &amp;,\ i&gt;0 \end{cases} \]</span></p><p>注意有可能存在没有钱找零的情况，对应于dp[i-coins[j]]==INT_MAX，此时要返回-1。最终代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(coins.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>]();</span><br><span class="line">    <span class="keyword">int</span> sz=coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;++i)&#123;</span><br><span class="line">        dp[i]=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coins[j]&lt;=i&amp;&amp;dp[i-coins[j]]!=INT_MAX)&#123;</span><br><span class="line">                dp[i]=dp[i-coins[j]]+<span class="number">1</span>&lt;dp[i]?dp[i-coins[j]]+<span class="number">1</span>:dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount]==INT_MAX)?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机">买卖股票的最佳时机</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">【LeetCode 121】买卖股票的最佳时机</a></p><p>题目的意思是找到数组当中最大和最小元素差的最大值，且最小元素必须在最大元素之前。分析知道其实只需要维护一个cur_max和一个cur_min，让cur_max始终保留当前价格和cur_min差值的最大值即可。代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz=prices.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sz&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur_min=prices[<span class="number">0</span>],cur_max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz;++i)&#123;</span><br><span class="line">        cur_max=<span class="built_in">max</span>(cur_max,prices[i]-cur_min);</span><br><span class="line">        cur_min=<span class="built_in">min</span>(cur_min,prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--数学模拟专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%8B%9F%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Mon Mar 23 2020 15:43:24 GMT+0800 (GMT+08:00) --><h2 id="进制转换">进制转换</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344" target="_blank" rel="noopener">【PAT B1022】D进制的A+B</a></p><h3 id="p进制数x转换为十进制数y">P进制数x转换为十进制数y</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> y=<span class="number">0</span>, product=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">    y=y+(x%<span class="number">10</span>)*product;</span><br><span class="line">    x/=<span class="number">10</span>;</span><br><span class="line">    product*=P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将十进制数y转换为q进制数x">将十进制数y转换为Q进制数x</h3><p>注意一定要用<strong>do……while循环</strong>，而非while循环</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">32</span>], num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    z[num]=y%Q;</span><br><span class="line">    ++num;</span><br><span class="line">    y/=Q;</span><br><span class="line">&#125;<span class="keyword">while</span>(y!=<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p></p><h2 id="最长前缀串">最长前缀串</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/" target="_blank" rel="noopener">【LeetCode 1071】字符串的最大公因子</a></p><p>题目意思就是找到字符串S和T的最长公共子串。最巧妙的解法是，由于S+T==T+S是S和T有最长公共子串的充要条件，所以只需要判断他们俩相连是否相同，如果相同则直接输出长度为<span class="math inline">\(gcd(\textit{len}_1,\textit{len}_2)\)</span>的前缀串即可，否则返回空串。代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 + str2 != str2 + str1) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">return</span> str1.substr(<span class="number">0</span>, __gcd((<span class="keyword">int</span>)str1.length(), (<span class="keyword">int</span>)str2.length()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多数元素">多数元素</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">【LeetCode 169】多数元素</a></p><p>题目意思是给定一个数组，找到在里面出现次数超过<span class="math inline">\(\lfloor\dfrac{n}{2}\rfloor\)</span>的数。</p><p>可以用计数方法解决，相同则count++，不同则count--，这个是算法课上应该会讲到的经典算法。代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> most_val;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sz=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(i&lt;sz)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            most_val=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==most_val)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> most_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>数学</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>写在一周年</title>
    <url>/%E9%82%A3%E4%B8%80%E5%B9%B4/%E5%86%99%E5%9C%A8%E4%B8%80%E5%91%A8%E5%B9%B4/</url>
    <content><![CDATA[<!-- build time:Mon Mar 23 2020 15:43:24 GMT+0800 (GMT+08:00) --><p><em>这是2019年12月1日的推送，首发于公众号“酸辣目鱼汤”。虽然作者是我，但是编辑是她。我想将文章转载于此，暂托因新型冠状病毒肺炎疫情而不得见面的遗憾。</em></p><p><br></p><center>0</center><p><br></p><p>这是我在南京大学第三个冬天了。去年这个时候，我结交了一个人，她19岁。</p><p>我很害怕，害怕认识别人。自主招生为学弟学妹家长答疑的那个下午，我早早来到了教室，低着头，找到一个后排的座位躲了起来。“嗨！”她对我说。“嗨。”我怯生生地，心里想着这是谁呢？</p><p>福建同乡群里，她说明天回家，可是箱子好重。在食堂的我顿时陷入“茶饭不思”的状态。一个小时以后，我对自己说：这可能是一个改变你未来的决定。“我能帮你提箱子吗？”实话说，那时候的我多么希望你断然拒绝，终结我的一切念想。“好！”你说。这真是一个超纲题。</p><p><br></p><center>1</center><p><br></p><p>那个暑假很漫长，漫长得我对未来感到很绝望：要是被别人表白了怎么办，我是不是就没有机会了？我知道你的生日是9月5日，我买了你心心念念的礼物，在礼物的夹层里塞了我誊写了好几遍的情书。我把情书拿出来，又塞进去，拿出来再添了两个字，又塞进去压好——那是我一年多来写字写得最认真的时候了。</p><p>像《一千零一夜》，我把“早安”和“晚安”换着31*2=62种互不相同的方法在每个早上醒来之后和晚上睡去之前和你说。你也会回我——通常是晚上11点和中午11点。那个暑假，我要在早上8点起床和11点之间每一会儿就打开手机看看你有没有回我。有的时候，明明知道你11点才起床，但你那么久不回，我仍然会感到难过。</p><p><br></p><center>2</center><p><br></p><p>新学期每个周末的早上，我会如约等候在你的宿舍楼下，一边想着你今天会穿什么样的衣服，会梳什么样的头发，一边看着时间超过1分钟，2分钟……或许这就是可爱吧。</p><p>我们订了12月1日晚上的江苏大剧院的《戏台》。回去的路上，路程很漫长，空空荡荡的车厢外，繁星很美好。</p><p>那天晚上，我写道“其实你好多好多瞬间都可爱到我了……比如说吃东西吃着吃着嘴角就有酸奶的沫沫或者小粒的米饭、转头看我的时候黑色眼眸的扑朔迷离、夜晚地上你的晃头晃脑的影子，还有捋左边一小撮头发时候歪斜着头的模样，喝完酸奶把吸管咬得扁扁的折来折去……”</p><p><br></p><center>3</center><p><br></p><p>我发现我已经逐渐开始过起了无法脱离你的生活，一个人去食堂的时候想拿两个盘子，走在路上的时候感觉手上少提了什么，在图书馆的时候老是看看隔壁有没有你的影子，坐在地铁上，左边和右边却都是不认识的人。</p><p>有的时候未来真是一种很玄幻的东西，我们也早早开始为彼此的未来考虑、尝试去做出决定。我很爱你，我希望能够给你安稳幸福。不要离你太远，要常伴身边。要你时时快乐，要你活泼天真。可就算到了要和所有记忆握手言和的时候，我也希望你能够活在时间里，没有烟火气，笑靥如花。</p><p>或许不久之后再回来看这些文字，我还是会说自己不解风情吧。</p><p><br></p><center>4</center><p><br></p><p>最后，建议用Python运行如下神秘代码：</p>print('<!-- rebuild by neat -->]]></content>
      <categories>
        <category>那一年</category>
      </categories>
      <tags>
        <tag>那一年</tag>
      </tags>
  </entry>
  <entry>
    <title>建站撒花</title>
    <url>/%E7%AB%99%E5%8A%A1/%E5%BB%BA%E7%AB%99%E6%92%92%E8%8A%B1/</url>
    <content><![CDATA[<!-- build time:Mon Mar 23 2020 15:43:24 GMT+0800 (GMT+08:00) --><p>欢迎来到我的小站！这是我的个人博客，您可以在这里看到我的日常生活或技术总结。我将不定时对我的博客进行更新。</p><p>如果您对我的博客感兴趣，可以打赏或者向朋友分享！如果想要与我深入交流，请给我发邮件：<a href="mailto:njulh2017@outlook.com">njulh2017@outlook.com</a>，或者访问我的个人主页：<a href="https://lajioj.github.io/haol/" class="uri">https://lajioj.github.io/haol/</a>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>站务</category>
      </categories>
      <tags>
        <tag>站务</tag>
      </tags>
  </entry>
</search>
