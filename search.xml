<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>机试知识点--树专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 10:47:39 GMT+0800 (GMT+08:00) --><h1 id="二叉搜索树">二叉搜索树</h1><h2 id="独立的二叉搜索树有几个">独立的二叉搜索树有几个</h2><p>题目链接：<a href="https://pic.leetcode-cn.com/fe9fb329250b328bb66032dda25b867e0047fcb480c2c0bcf14ecc2a4c12e454-image.png" target="_blank" rel="noopener">【LeetCode 96】Unique Binary Search Trees</a></p><p>这是一个组合计数问题，其实可以归约到卡特兰数问题。<img src="https://pic.leetcode-cn.com/fe9fb329250b328bb66032dda25b867e0047fcb480c2c0bcf14ecc2a4c12e454-image.png" alt="题图"></p><p>根据LeetCode官方的图解可知，卡特兰数问题就是中间选一个作为根节点，然后把两边的卡特兰数集合作笛卡尔积，求势可得<span class="math inline">\(F[i]=G[i-1]G[n-i]\)</span>。把所有这样的<span class="math inline">\(F[i]\)</span>求和即可得到卡特兰数。因此卡特兰数的动规方程是： <span class="math display">\[ G[i]=\begin{cases} 1&amp;,\ i=0,\ 1\\ G(0)G(n-1)+G(1)G(n-2)+\dots+G(n-1)G(0)&amp;,\ i\geq 2 \end{cases} \]</span> 递推公式是： <span class="math display">\[ G[0]=1,\ G[n+1]=\dfrac{2(2n+1)}{n+2}G[n] \]</span> 通项公式是： <span class="math display">\[ G[n]=\dfrac{\dbinom{2n}{n}}{n+1} \]</span> 还有很多同类组合计数问题也可以直接用卡特兰数求解，包括：</p><ul><li>进出栈问题：一个足够大的栈的进栈序列为<span class="math inline">\(1,2,3,⋯,n\)</span>时有多少个不同的出栈序列？</li><li>二叉树构成问题：有<span class="math inline">\(n\)</span>个结点，问总共能构成几种不同的二叉树？</li><li>凸多边形的三角形划分：一个凸的<span class="math inline">\(n\)</span>边形，用直线连接他的两个顶点使之分成多个三角形，每条直线不能相交，问一共有多少种划分方案？</li><li>有n+1个叶子的满二叉树的个数？（提示：向左记为+1，向右记为−1，按照向左优先的原则，从根节点开始遍历）</li><li>在n*n的格子中，只在下三角行走，每次横或竖走一格，有多少中走法？（提示：横进栈竖出栈，本质上也是卡特兰数问题）</li><li>由nn对括号形成的合法括号表达式的个数？</li><li>等等</li></ul><p>卡特兰数动规解法如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *cat=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>]();</span><br><span class="line">cat[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">cat[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>,k=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=i<span class="number">-1</span>&amp;&amp;k&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        cat[i]+=(cat[j]*cat[k]);</span><br><span class="line">        ++j;</span><br><span class="line">        --k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>卡特兰数更加便于计算的递推公式解法如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> C=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">    C=C*<span class="number">2</span>*(<span class="number">2</span>*i+<span class="number">1</span>)/(i+<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意为了防止分子的<span class="math inline">\(C\)</span>溢出，即使最后返回int型，也要用long型计算。<p></p><h2 id="独立的二叉搜索树有几个进阶版">独立的二叉搜索树有几个——进阶版</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">【LeetCode 95】Unique Binary Search Trees II</a></p><p>这题是上一题的进阶版，题目要求输出所有可能的序列。此处考虑分治算法，对任意的<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>，可以以<span class="math inline">\(i\)</span>为根节点遍历之，每次取<span class="math inline">\(1\)</span>到<span class="math inline">\(i-1\)</span>和<span class="math inline">\(i+1\)</span>到<span class="math inline">\(n\)</span>分治求所有可能的组合即可。</p><p>另外，这一题存在一些边缘情况应该考虑清楚，例如start&gt;end，n=0等。参考源码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; forRobust;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> forRobust;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> divideConquer(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">divideConquer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; start,<span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt;ans;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;<span class="built_in">end</span>)&#123;</span><br><span class="line">        ans.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=<span class="built_in">end</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt;leftSubTree=divideConquer(start,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt;rightSubTree=divideConquer(i+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;leftSubTree.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;rightSubTree.<span class="built_in">size</span>();++k)&#123;</span><br><span class="line">                TreeNode* thisRoot=<span class="keyword">new</span> TreeNode(i);<span class="comment">//注意这里应该new一个i来push到ans中</span></span><br><span class="line">                thisRoot-&gt;left=leftSubTree[j];</span><br><span class="line">                thisRoot-&gt;right=rightSubTree[k];</span><br><span class="line">                ans.push_back(thisRoot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效的二叉搜索树">有效的二叉搜索树</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">【LeetCode 98】Validate Binary Search Tree</a></p><p>题目的意思是判断一个二叉搜索树是否满足下列条件： - 一个结点的左子树只包含值比当前结点的值<strong>小</strong>的结点 - 一个结点的右子树只包含值比当前结点的值<strong>大</strong>的结点 - 左子树和右子树必须也是有效的二叉搜索树</p><p>有两种解决思路，一种是根据定义递归，每次遇到一个新结点便划分区间，然后判断子树是否在划分的区间内即可；另一种思路是把树表示成中序遍历的形式，根据定义易知此时遍历序列为升序序列即可。</p><p>第一种思路的代码如下，注意用到long long型是因为如果测试样例存在2147483647的话划分区间会出问题而返回false。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myJudge(root,<span class="built_in">min</span>,<span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">myJudge</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> left,<span class="keyword">long</span> <span class="keyword">long</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;=left||root-&gt;val&gt;=right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myJudge(root-&gt;left,left,root-&gt;val)</span><br><span class="line">            &amp;&amp;myJudge(root-&gt;right,root-&gt;val,right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">min</span>=<span class="number">-9223372036854775808</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">max</span>=<span class="number">9223372036854775807</span>;</span><br></pre></td></tr></table></figure><p></p><p>第二种思路的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TraverseBST(root);</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vec.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i<span class="number">-1</span>]&gt;=vec[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TraverseBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TraverseBST(root-&gt;left);</span><br><span class="line">        vec.push_back(root-&gt;val);</span><br><span class="line">        TraverseBST(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec;</span><br></pre></td></tr></table></figure><p></p><h2 id="树的同构">树的同构</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/1211841066264109056/problems/1234055373040824320" target="_blank" rel="noopener">【PAT 03】树的同构</a></p><p>题目意思是：给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。有一种暴力的思路是枚举所有可能的互换结果，还有一种剪枝策略可以大大缩小解空间：T1和T2同构当且仅当两个树的同一个结点的(左子树与右子树均分别相同)或(T1的左子树等于T2的右子树且T1的右子树等于T2的左子树)。</p><p>这一题还有一个小trick，就是它的两棵树的结点信息如下给出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">A <span class="number">1</span> <span class="number">2</span></span><br><span class="line">B <span class="number">3</span> <span class="number">4</span></span><br><span class="line">C <span class="number">5</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">6</span> -</span><br><span class="line">G <span class="number">7</span> -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">G - <span class="number">4</span></span><br><span class="line">B <span class="number">7</span> <span class="number">6</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">5</span> <span class="number">1</span></span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">2</span> -</span><br></pre></td></tr></table></figure>对应的树为<img src="https://images.ptausercontent.com/28" alt="题图">也即列举的第一个结点完全可以不是树的根节点。为了解决这个问题，我们首先要用结构数组来储存树的信息，继而观察可以知道<strong>没有出现</strong>在左右子节点的数字即为根节点的数组下标，上面的两棵树的数组下标即为0和3，对应结点都为A。<p></p><p>另外有一个坑点是数据结构小白教程里面输入数据的读法有问题，用scanf(&quot;%c&quot;)的类似形式来读会出现偏差，最后用cin才把输入数据读好的——这启示我如果以后遇到读char类型的题目，搞不清楚还是尽量用cin。</p><p>最后可以写出代码，此处就不贴出了。</p><h2 id="前序和中序建立树">前序和中序建立树</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">【LeetCode 105】从前序与中序遍历序列构造二叉树</a></p><p>题目意思很简单，即从给出的前序和中序遍历序列构造一棵树，这是数据结构的基本问题，直接贴上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inorder.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder,<span class="number">0</span>,inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">const</span> <span class="keyword">int</span>&amp; prel, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">const</span> <span class="keyword">int</span>&amp; inl, <span class="keyword">const</span> <span class="keyword">int</span>&amp; inr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prel&gt;=preorder.<span class="built_in">size</span>()||inl&gt;inr)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* p=<span class="keyword">new</span> TreeNode(preorder[prel]);</span><br><span class="line">    <span class="keyword">if</span>(inl==inr)&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=inl;i&lt;=inr;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i]==preorder[prel])&#123;</span><br><span class="line">            p-&gt;left=build(preorder,prel+<span class="number">1</span>,inorder,inl,i<span class="number">-1</span>);</span><br><span class="line">            p-&gt;right=build(preorder,prel+i-inl+<span class="number">1</span>,inorder,i+<span class="number">1</span>,inr);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是p-&gt;right这条语句中对preorder数组传入的偏移量应该为prel+i-inl+1。</p><h1 id="树易错知识点回顾">树易错知识点回顾</h1><h2 id="树">树</h2><ul><li>结点的度：该结点的子树个数</li><li>树的表示方法：儿子-兄弟表示法，一个指针指儿子，另一个指针指同层兄弟</li></ul><h2 id="二叉树">二叉树</h2><ul><li>n个结点的判定树深度为<span class="math inline">\(\lfloor log_2n\rfloor+1\)</span></li><li>11个结点的判定树查找的平均成功查找次数<span class="math inline">\(ASL=(4\times 4+4\times 3+2\times 2+1)/11=3\)</span></li><li>对任何非空二叉树T，若<span class="math inline">\(n_0\)</span>表示叶节点的个数，<span class="math inline">\(n_2\)</span>是度为2的非叶节点个数，那么两者满足<span class="math inline">\(n_0=n_2+1\)</span><ul><li>由总结点数-1=总边数，即<span class="math inline">\(n_0+n_1+n_2-1=0\times n_0+1\times n_1+2\times n_2\)</span>可证得该结论</li></ul></li><li>数组实现的二叉树存储：<ul><li>非根节点的的父节点序号是<span class="math inline">\(\lfloor i/2\rfloor\)</span>；</li><li>结点<span class="math inline">\(i\)</span>的左孩子的结点序号是<span class="math inline">\(2i, 2i\leq n\)</span>；</li><li>结点<span class="math inline">\(i\)</span>的右孩子的结点序号是<span class="math inline">\(2i+1, 2i+1\leq n\)</span>.</li></ul></li><li>中序遍历的非递归算法：使用堆栈，先序类似；层序遍历：队列<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 遇到一个结点，压栈并遍历左子树</span><br><span class="line">2. 左子树遍历结束后从栈顶弹出并访问这个结点</span><br><span class="line">3. 然后中序遍历右子树</span><br></pre></td></tr></table></figure></li><li>求二叉树的高度：左右子树高度求出后才能求当前结点高度，因此改造后序遍历算法即可</li><li>中序遍历输出中缀表达式：存在运算符优先级的问题，如何解决？<ul><li>输出左子树的时候先输出一个左括号，左子树结束的时候加入右括号</li></ul></li><li>前序后序能否确定一个唯一的二叉树？不能</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据实验</title>
    <url>/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 10:47:39 GMT+0800 (GMT+08:00) --><h2 id="课程相关">课程相关</h2><ul><li>成绩组成<ul><li>期末考试50%，基本原理、方法、概念、书面编程题</li><li>课程实验25%，5次，每次5%，共计25%</li><li>课程设计25%，暑期7月份有20多天完成</li></ul></li><li>教材：深入理解大数据——大数据编程技术与实践</li></ul><h2 id="第一章-并行计算与大数据处理技术概述">第一章 并行计算与大数据处理技术概述</h2><h3 id="为什么要并行计算">为什么要并行计算</h3><ul><li>提高计算机性能的主要手段<ul><li>提高处理器字长</li><li>提高集成度</li><li>流水线等微体系结构技术：实现指令级并行<ul><li>RISC结构</li><li>5级流水线</li><li>分支预测</li><li>寄存器重命名</li><li>超长指令字、乱标量等……</li></ul></li><li>提高处理器频率</li></ul></li><li>为什么需要并行计算？<ul><li>单核处理器性能提升接近极限<ul><li>VLSI集成度不可能无限制提高</li><li>ILP墙：处理器的指令级并行度提升接近极限</li><li>存储墙：处理器速度和存储器速度差异越来越大</li><li>功耗墙：功耗和散热大幅增加超过芯片承受能力</li></ul></li><li>单处理器向多核/众核并行计算发展成为必然趋势<ul><li>多（Multicore）核并行计算</li><li>众（Manycore）核并行计算</li></ul></li><li>应用领域计算规模和复杂度大幅度提高<ul><li>爆炸性增长的Web规模数据量</li><li>超大的计算量/计算复杂度</li></ul></li></ul></li></ul><h3 id="并行计算技术的分类">并行计算技术的分类</h3><ul><li>按数据和指令处理结构：弗林(Flynn)分类（体系结构角度分类）<ul><li>单指令单数据流(SISD)、单指令多数据流(SIMD)、多指令单数据流(MISD)：很少使用、多指令多数据流(MIMD)：最常用</li></ul></li><li>按并行类型（应用角度分类）<ul><li>位级并行、指令级并行、线程级并行（数据级并行、任务级并行）</li></ul></li><li>按存储访问构架<ul><li>共享内存（也称UMA）：通过总线共享内存</li><li>分布共享存储体系结构：各处理器本地有存储器，同时共享全局存储器</li><li>分布式内存：各处理器使用本地独立的存储器</li></ul></li><li>按系统类型<ul><li>多核/众核并行计算系统(MC)、对称多处理器系统(SMP)、大规模并行处理(MPP)、集群(Cluster)、网格(Grid)</li><li>上面几种系统类型中耦合度越前面越高，可扩展性越后面越高，系统规模越后面越高、能耗（一般来说与系统规模成正比）越后面越高</li></ul></li><li>按计算特征：大数据时代主要解决数据密集型和混合型并行计算<ul><li>数据密集型并行计算：如大规模Web信息搜索</li><li>计算密集型并行计算：如3D建模与渲染、气象预报、科学计算</li><li>数据密集型与计算密集型混合型并行计算：3D电影渲染</li></ul></li><li>按并行程序设计模型/方法<ul><li>共享内存变量：如pthread、OpenMp</li><li>消息传递方式：如MPI</li><li>MapReduce方式：MapReduce并行程序设计模型</li></ul></li></ul><h3 id="并行计算的主要技术问题">并行计算的主要技术问题</h3><p><em>数据怎么存，怎么算？（并行算法、软件构架、硬件构架）</em> - 多核/多处理器网络互连结构技术 - 存储访问体系结构 - 共享存储器体系结构 - 分布存储体系结构 - 分布共享存储体系结构 - 分布式数据与文件管理 - 并行计算任务分解与算法设计 - 并行程序设计模型和方法 - 共享内存式（适用共享内存结构）、消息传递式（适用分布内存结构）、MapReduce并行程序设计 - 并行程序设计语言 - 语言、库函数、接口 - 并行编译优化 - 数据同步访问和通信控制 - 可靠性技术与容错技术 - 数据失效恢复、系统和任务失效恢复 - 并行计算软件框架平台 - 提供自动化并行处理能力 - 高可拓展性和系统性能提升 - 系统性能评价和程序并行度评估 - 系统性能评价：例如Benchmark等 - 程序并行度评估 - 程序并行加速评估公式<strong>Amdahl定律,其中<span class="math inline">\(S\)</span>是加速比，<span class="math inline">\(P\)</span>是程序可并行比例、<span class="math inline">\(N\)</span>是处理器数目：（需要掌握）</strong> <span class="math display">\[S=\frac{1}{1-P+\frac{P}{N}}\]</span> - 所以，<strong>一个并行程序可加速程度是有限制的，并非无限加速，也并非程序越多越好</strong></p><h3 id="mpi并行程序设计">MPI并行程序设计</h3><ul><li>方便计算密集型，不方便数据密集型</li><li>功能：用常规语言编程方式，所有节点运行同一个程序，但处理不同的数据，提供点对点（同步、异步）、节点集合（同步、数据移动、数据规约）通信和用户自定义复合数据类型传输<ul><li>数据规约：将一组进程的数据按照指定的操作方式规约到一起并传送给一个进程，操作保证满足交换律、结合律</li></ul></li><li>MPI如何编程不是重点</li><li>MPI的特点<ul><li>灵活性好，适合于各种计算密集型的并行计算任务</li><li>独立于语言的编程规范，可移植性好</li><li>有很多开放机构或厂商实现并支持</li></ul></li><li>MPI的不足<ul><li>无良好的数据和任务划分支持</li><li>缺少分布文件系统支持分布数据存储管理（MPI只负责消息传递）</li><li>通信开销大，当计算问题复杂、节点数量很大时，难以处理，性能大幅下降</li><li>无节点失效恢复机制，一旦有节点失效，可能导致计算过程无效</li><li>缺少良好的构架支撑，程序员需要考虑以上所有细节问题，程序设计较为复杂</li></ul></li></ul><h3 id="为什么需要大数据并行处理技术">为什么需要大数据并行处理技术？</h3><ul><li>一些点<ul><li>信息检索、自然语言理解和机器学习的三个要素：数据，特征，与算法</li></ul></li></ul><h3 id="什么是大数据">什么是大数据</h3><ul><li>大数据是指无法使用常用的软件工具在一定时间内完成获取、管理和处理的数据集。</li><li>特点：4V+1C或5V(多了一个Value)<ul><li>Volume:大容量，TB-ZB</li><li>Variety:多样性</li><li>Velocity:时效性</li><li>Veracity:准确性</li><li>Complexity:复杂性</li></ul></li><li>大数据的类型：<ul><li>结构特征<ul><li>结构化数据</li><li>非结构化、半结构化数据</li></ul></li><li>获取和处理方式<ul><li>动态（流式、增量式、线上）、实时数据</li><li>静态（线下数据）、非实时数据</li></ul></li><li>关联特征<ul><li>无关联、简单关联数据（键值记录型数据）</li><li>复杂关联数据（图数据）</li></ul></li></ul></li><li>大数据研究的基本途径<ul><li>寻找新算法：降低计算复杂度</li><li>降低大数据尺度：寻找数据尺度无关算法</li><li>大数据并行化处理：分而治之</li></ul></li><li>大数据研究<ul><li>系统观点：基础设施<span class="math inline">\(\rightarrow\)</span>系统平台<span class="math inline">\(\rightarrow\)</span>算法<span class="math inline">\(\rightarrow\)</span>应用</li><li><strong>从MapReduce</strong>, BSP, MPI, CUDA, OpenMP , 定制式混合式如 MapReduce+CUDA , MapReduce+MPI<strong>变成Hadoop与Spark主流并行计算模型与系统</strong>，包括批处理计算，流式计算，图计算，迭代计算，混合式计算，定制式计算</li></ul></li><li><strong>MapReduce定义（老师的要求）</strong>：是面向大规模数据并行处理的<ul><li>基于集群的高性能并行计算平台（Cluster）</li><li>并行程序开发与运行框架（Software）</li><li>并行程序设计模型与方法（Programming Model &amp; Methodology）</li></ul></li></ul><h2 id="第二章-mapreduce简介">第二章 MapReduce简介</h2><h3 id="mapreduce简介">MapReduce简介</h3><ul><li><strong>什么是MapReduce</strong>(老师希望问的时候能够答出来)<ul><li>对付大数据处理：分而治之</li><li>构建抽象模型：Mapper和Reducer</li><li>上升到构架：自动并行化并隐藏底层细节</li></ul></li></ul><h4 id="对付大数据处理分而治之">对付大数据处理：分而治之</h4><ul><li>什么样的计算任务不可进行并行计算？<ul><li>不可分拆的计算任务或相互间有依赖关系的数据无法进行并行计算</li></ul></li><li>主从式架构<ul><li>Master：负责划分和分配任务</li><li>Worker：负责数据块计算</li></ul></li><li>大数据计算任务-&gt;很多子任务-&gt;计算结果</li></ul><h4 id="构建抽象模型mapper和reducer">构建抽象模型：Mapper和Reducer</h4><ul><li>函数式程序设计语言Lisp<ul><li>Map：对一组数据元素进行某种重复式的处理（执行同一种映射）</li><li>Reduce：对Map的中间结果进行某种进一步的结果整理（整理Map结果）</li></ul></li><li>MPI接口的Reduce操作只支持有限的操作，不允许复合操作</li><li>关系数据库中的聚合操作和Reduce操作很类似</li><li>典型的流式大数据问题的特征<ul><li>Map<ul><li>大量数据记录 元素进行重复处理</li><li>对每个数据记录 元素作感兴趣的处理、获取感兴趣的中间结果信息</li></ul></li><li>排序和整理中间结果以利后续处理</li><li>Reduce<ul><li>收集整理中间结果</li><li>产生最终结果输出</li></ul></li></ul></li><li>关键思想：为大数据处理过程中的两个主要处理操作提供一种<em>抽象机制</em></li><li>Map: (k1; v1) -&gt; [(k2; v2)]<ul><li>输入键值对，以另一种键值对形式（类型可以不一样，可以生成一组）输出</li></ul></li><li>Reduce : (k2; [v2]) -&gt; [(k3; v3)]<ul><li>输入：由Map输出的一组键值对[(k2; v2)]有相同主键的合并，将不同数值合并到一个列表[v2]中</li><li>处理：对传入的中间结果列表数据进行某种整理或进一步的处理</li><li>输出：最终输出结果[(k3; v3)]（元素类型可以不一样，可以有多个，也可以只有一个）</li></ul></li><li>Map和Reduce为程序员提供了一个清晰的操作接口抽象描述</li><li>海量数据存储-&gt;数据划分后Map-&gt;中间结果Shuffle-&gt;Reduce-&gt;计算结果<ul><li>注意<ul><li>每个Map和每个Reduce的逻辑是一样的</li><li>并行计算的时候每个是同时进行计算的</li><li>进行reduce处理之前，必须等到所有的map函数做完，所以需要一个同步障Barrier，聚合并洗牌</li></ul></li></ul></li></ul><h4 id="上升到构架自动并行化并隐藏低层细节">上升到构架：自动并行化并隐藏低层细节</h4><ul><li>MapReduce提供主要功能<ul><li>任务调度：划分、分配、调度、控制、监控、优化</li><li>数据/代码互定位：减少数据通信次数，本地化数据处理</li><li>出错处理：检测、隔离、调度错误结点</li><li>分布式数据存储与文件管理：管理大规模数据</li><li>Combiner和Partitioner：减少数据通信开销<ul><li>数据处理路径：Map-&gt;Combiner-&gt;Partitioner-&gt;Reduce</li></ul></li></ul></li></ul><h3 id="mapreduce主要设计思想与特点">MapReduce主要设计思想与特点</h3><ul><li>向外横向拓展，而非向上纵向拓展</li><li>失效是常态</li><li>把处理向数据迁移</li><li>顺序处理数据、避免随机访问数据</li><li>为应用开发者隐藏系统层细节</li><li>平滑无缝的可拓展性<ul><li>数据拓展和系统规模拓展</li></ul></li></ul><h2 id="第三章-google和hadoop-mapreduce">第三章 Google和Hadoop MapReduce</h2><h3 id="google-mapreduce的基本工作原理">Google MapReduce的基本工作原理</h3><ul><li>计算过程：见PPT</li><li></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>大数据实验</category>
      </categories>
      <tags>
        <tag>大三下</tag>
        <tag>大数据实验</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘导论</title>
    <url>/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AF%BC%E8%AE%BA/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 10:47:39 GMT+0800 (GMT+08:00) --><h2 id="课程信息">课程信息</h2><ul><li>教材：Data Mining: Concepts and Techniques, 3rd edition. Elsevier Inc, 2012</li><li>成绩：<ul><li>Final exam 闭卷(30%)</li><li>Assignments (30%)</li><li>Data Mining Practice (40%)<ul><li>5月左右布置，有一个月左右时间完成</li></ul></li></ul></li><li>目标：锻炼数据思维<ul><li>科学研究的第四范式：基于数据的角度，“万物皆数据”</li></ul></li></ul><h2 id="引言">引言</h2><ul><li>先决条件：计算机硬件、软件技术、网络<span class="math inline">\(\rightarrow\)</span>采集数据方便且海量<span class="math inline">\(\rightarrow\)</span>大数据</li><li>为什么要数据挖掘？<ul><li>大数据有巨大的价值，Data are rich</li><li>但是大数据太多了，无法找到有用的信息，Info is poor</li></ul></li><li>数据挖掘得到什么？<ul><li>知识、关系、真理<span class="math inline">\(\rightarrow\)</span>对决策有用的信息</li></ul></li><li>举例<ul><li>超市购买商品：啤酒和尿布</li><li>潜在客户挖掘：哪些客户会从2G转化为3G？</li><li>网络入侵模式：决定当前结点正在被侵入</li><li>基因数据挖掘：通过基因表达确定基因功能</li><li>医疗数据挖掘：计算机辅助诊断</li><li>网络挖掘：网络结构、网页内容、使用习惯等用来网络搜索、用户行为检测</li><li>金融数据挖掘：欺诈检测、股票趋势发现</li><li>软件数据挖掘：挖掘源代码、运行时间等提升软件质量、生产效率、用户体验等</li><li>行为数据挖掘：Kinect</li><li>艺术数据挖掘：挖掘绘画的笔触、鉴定真伪、改变照片风格</li><li>语音生成：为无声视频产生音频</li><li>图像、视频编辑</li><li>总统竞选</li></ul></li><li>数据挖掘定义？没有确切定义<ul><li>数据挖掘是从<strong>巨量数据</strong>中获取<strong>正确的、新颖的、潜在有用的、最终可理解</strong>的模式的<strong>非平凡</strong>过程</li><li>最终可理解？其实一部分机器学习方法是不可理解的，因此一定要注意有些情况下可理解性必须要有，而有些情况下可理解性可不必有。</li></ul></li><li>Knowledge Discovery in Data(KDD)<ul><li>数据清洗、数据仓库、数据选择、数据挖掘、……</li></ul></li><li>DM和KDD的关系？<ul><li>包含、被包含、相等都有道理</li><li>现在绝大部分人认为二者都是对数据分析处理，是相同的概念</li></ul></li><li>什么数据可以被挖掘？<ul><li>&quot;Flat&quot; data: table or matrix</li><li>数据仓库（Data warehouse）</li><li>文本数据（Text data）</li><li>多媒体数据（Multimedia data）：音频、视频、图像等</li><li>网络数据（Web data）</li><li>社交网络数据（Social network data）</li><li>时间、空间数据（Temporal and spatial data）</li></ul></li><li>数据挖掘任务分类<ul><li>描述型挖掘任务：数据的总体性质，例如分布、统计量等</li><li>预测型挖掘任务：建立模型来预测未来的事件，数据量较描述型任务更多</li></ul></li><li>哪一些模式可以被挖掘？<ul><li>特征Characterization：例如提取CS学生的特征</li><li>区别Discrimination：例如对比CS和Art两个院系的学生</li><li>联系Association：例如买面包大概率也买牛奶<ul><li>挑战：找到关系</li></ul></li><li>聚类Clustering：例如根据外观把不同瓷器分成不同时期的<ul><li>挑战：找到相似度并划分</li></ul></li><li>分类Classification：例如根据外观确定一个瓷器是不是某时期的<ul><li>挑战：找到类和类的边界</li></ul></li><li>回归Regression：根据外观确定瓷器多少钱<ul><li>挑战：建立输入和输出的映射</li></ul></li><li>离群分析Outlier analysis：在现有的瓷器市场中找到古代瓷器<ul><li>挑战：对微弱信号的敏感性</li></ul></li><li>趋势和演化分析Trend and evolution analysis：找到瓷器价格改变的模式（怎么从前面的值变成现在的值）<ul><li>挑战：如何为变化的模式建立模型</li></ul></li></ul></li><li>如何评估挖掘结果？<ul><li>客观评价Objective measures：基于数据和模式结构<ul><li>例如：support and confidence</li></ul></li><li>主观评价Subjective measures：基于用户对数据的信念<ul><li>例如：unexpectedness and actionability</li></ul></li></ul></li></ul><h2 id="第二章-数据立方体与olap">第二章 数据立方体与OLAP</h2><h3 id="数据仓库">数据仓库</h3><ul><li>特点：面向主题、</li><li>数据仓库与DBMS<ul><li>DBMS：On-Line Transaction Processing联机事务处理(OLTP)</li><li>数据仓库：On-Line Analytical Processing联机分析处理(OLAP)</li></ul></li><li>数据仓库的数据模型：多维数据模型<ul><li>注意：<ul><li>维度Dimension：关心实体的不同方面<ul><li>例如：产品、市场、时间、销售量是一个四维的多维数据模型</li></ul></li><li>量Scale：该方面的大小</li></ul></li><li>多维数据模型的核心：数据立方体</li></ul></li></ul><h3 id="数据立方体与olap">数据立方体与OLAP</h3><ul><li>什么是数据立方体？<ul><li>数据立方体是（长方体的）格（The lattice of cuboids）</li><li>每一个晶格是一个张量（tensor）</li></ul></li><li>多维数据模型存储方式<ul><li>星型模型Star schema：事实表为中心，维表为周边</li><li>雪花模型Snowflake schema：事实表为中心，多重维表嵌套<ul><li>节省空间、牺牲性能</li></ul></li><li>事实星座模型Fact constellation schema/星系模型Galaxy schema：多个事实表、维表相连接</li><li>注意：在每一种存储方式中均包含维表(dimensional table)和事实表(fact table)</li></ul></li><li>什么是概念层级Concept hierarchy？<ul><li>例如location: all-country-province_or_state-street</li><li>层次结构说明：Schema hierarchy, set-grouping hierarchy</li></ul></li><li>数据立方体上的OLAP操作<ul><li>上卷roll-up：</li><li>下钻drill-down：</li><li>切片slice：</li><li>切块dice：</li><li>转轴pivot/旋转rotate：</li></ul></li><li>Mesaure：能够在数据立方体空间任意位置进行评估的数值函数<ul><li>通常用分布式聚合函数</li><li>三类，优先级distributive&gt;algebraic&gt;holistic<ul><li>分布式：仅分布式聚合函数<ul><li>例如：count,sum,min,max</li></ul></li><li>数值型：在分布式聚合函数得到值的基础上再次进行数值计算<ul><li>例如：avg,min_N,max_N,standard_deviation</li></ul></li><li>全面的：无法聚合的<ul><li>例如：rank,median,mode</li></ul></li></ul></li></ul></li><li>OLAP服务体系：关系OLAP(ROLAP)、多维OLAP(MOLAP)、混合OLAP(HOLAP)……</li><li>预计算：高速响应+避免重复计算<ul><li>n维数据立方体lattice有多少？<ul><li>无层次：<span class="math inline">\(T=2^n\)</span></li><li>考虑概念层级每一维有<span class="math inline">\(L_i\)</span>层的概念层级：<span class="math inline">\(T=\prod_{i=1}^n(L_i+1)\)</span>，开销会变得更多<ul><li>10维4层有很大的开销</li></ul></li></ul></li></ul></li><li>做预计算的方法？<ul><li>不准备素材：只计算base cuboids，响应慢</li><li>完全素材：预计算所有cuboids，巨大存储开销</li><li>部分素材：预先计算一些cuboids，平衡上述两种<ul><li>基于连接频率、共享、更新等设计</li><li>一种流行的预计算方法：预先存下经常使用的素材</li></ul></li></ul></li><li>基于ROLAP的立方体计算，需要优化方法，相对慢<ul><li>最小孩子、缓存结果、分享类别</li></ul></li><li>基于MOLAP的立方体计算，基于<strong>多路数组聚合</strong>，相对快</li></ul><h4 id="多路数组聚合">多路数组聚合</h4><ul><li>方法：把多维数组划分为可以放入内存的chunks，以下以三维<span class="math inline">\(40*400*4000\)</span>的<span class="math inline">\(4*4*4\)</span>的<span class="math inline">\(A*B*C\)</span>的数据立方体为例说明<ul><li>注意应该同时计算AB，AC，BC</li><li>需要开辟的缓冲区大小：<ul><li>1234...64<ul><li>块1需要BC,AC,AB共3个面；块2需要AC,AB共2个面；块3,4同2；读完以后BC结果可以写回Disk（已经加好了）；</li><li>块5进来以后可以继续写块1开辟的BC，块5,6,7,8不需要另开辟AC面，因此只有AB平面需要开辟；</li><li>块13,14,15,16的AC面可以分别写入Disk</li><li>对BC平面：<span class="math inline">\(100*1000=100,000\)</span></li><li>对AC平面：就只有a0b0,a1b0,a2b0,a3b0四个即可，故<span class="math inline">\(4*10*100=40,000\)</span></li><li>对AB平面：要走到49开始直到64才可以写入Disk，需要<span class="math inline">\(4*10*4*100=16,000\)</span></li><li>总计<span class="math inline">\(156,000\)</span>个缓冲区</li></ul></li><li>1（另一个方向）：<span class="math inline">\(1,641,000\)</span></li></ul></li><li>结论：维度应该按照升序排序</li><li>最浪费空间：<span class="math inline">\(40*400+400*4000+40*4000\)</span></li></ul></li></ul><h4 id="索引olap数据">索引OLAP数据</h4><ul><li>Bitmap Index<ul><li>将每个维展开成二值的向量——bit操作很快</li></ul></li><li>Join Index（连接操作）<ul><li>例如Main Street直接连接到sales表，我们直接找项数少的Street表就可以，而不用找项数多的sales表</li></ul></li></ul><h4 id="元数据">元数据</h4><ul><li>定义：关于数据的数据</li><li>数据仓库元数据的类别：<ul><li>data source</li><li>data model</li><li>mapping</li><li>usage of warehouse contents</li></ul></li></ul><h3 id="olap和数据挖掘">OLAP和数据挖掘？</h3><ul><li>区别<ul><li>目标：OLAP交互数据分析，DM自动数据分析</li><li>功能：OLAP用户驱动，DM更广义</li><li>数据：OLAP用以分析数据仓库中的数据，DM不仅分析数据仓库</li></ul></li><li>OLAP和数据挖掘的集成：高质量数据、有效信息处理、基于OLAP的数据分析、在线选择DM函数</li><li>所以有了OLAM架构</li></ul><h3 id="olam架构">OLAM架构</h3><h4 id="olam框架的mining技术">OLAM框架的Mining技术</h4><ul><li>面向属性归纳法<ul><li>characterization：对data集合总结特征</li><li>comparison：对关心的data和别的data对照之下的特点</li></ul></li><li>步骤：<ul><li>数据聚焦Data focusing: 收集任务相关data</li><li>数据泛化Data generalization: 通过属性删除或属性generalization来<strong>generalization</strong><ul><li>此处：泛化是一个数据的抽象，概念层级的爬升</li><li>别的地方：学习器的泛化能力，把模型应用到未见场景的能力</li></ul></li><li>Presentation: 通过归并独特的，普遍的元组并accumulating their respective counts来应用聚合技术</li></ul></li><li>关键：<strong>DATA GENERALIZATION</strong></li></ul><h4 id="generalization">Generalization</h4><ul><li>控制泛化的技术？<ul><li>属性泛化阈值控制：属性值大于阈值，要属性删除和属性泛化</li><li>广义关系阈值控制：元组数量大于阈值，要泛化</li></ul></li><li>例如：name、phone删掉，但是birth-date泛化成age-range，birth-place泛化成birth-rigion，residence可以从住址泛化成城市、省份等，gpa可以离散化成ABC等级，末尾加一个count属性表示符合条件的原始表中有多少个</li></ul><h4 id="presentation">Presentation</h4><ul><li>表示方式：<ul><li>Generalized relation</li><li>Cross tab</li><li>Bar chart</li><li>Pie chart</li><li>3-D cube</li></ul></li></ul><h4 id="quantitative-characteristic-rule">Quantitative characteristic rule</h4><ul><li>t-weight: 占的比例，刻画了每一个class的分布</li><li>characteristic rule是target class的必要条件</li><li>target<span class="math inline">\(\Rightarrow\)</span>后面的条件</li></ul><h4 id="mining-class-comparisons">Mining class comparisons</h4><ul><li>通常情况下要一致对比，但也不绝对，例如可以比上海和韩国疫情，但一般不比中国和小地区的疫情</li></ul><h4 id="quantitative-discriminant-rule">Quantitative discriminant rule</h4><ul><li>d-weight: 在里面的概率是多少</li><li>discriminant rule是target class的充分条件</li><li><span class="math inline">\(d_{-}\)</span>weight<span class="math inline">\(=\operatorname{coumt}\left(q_{a} \in C_{\text {taget}}\right) / \sum_{i=1}^{N} \operatorname{count}\left(q_{a} \in C_{i}\right)\)</span></li><li>即A=q_a的时候C=target的概率为多少，<span class="math inline">\(P(C=target\|A=q_q)\)</span></li><li>condition里面的不同条件是合取，式子代表的是一个condition_i成立的时候，target成立的可能性是多少</li><li>target<span class="math inline">\(\Leftarrow\)</span>后面的条件</li><li>加起来不等于100，答案是target_class_port</li><li>d-weight不可以省略</li></ul><h4 id="quantitive-description-rule">Quantitive description rule</h4><ul><li>充要条件，析取，把t-weight和d-weight合起来写</li></ul><h3 id="重点不同顺序访问的时候乘起来空间多少t-weight和d-weight区别">重点：不同顺序访问的时候乘起来空间多少，t-weight和d-weight区别</h3><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据挖掘导论</category>
      </categories>
      <tags>
        <tag>大三下</tag>
        <tag>数据挖掘导论</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--线性表专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 10:47:39 GMT+0800 (GMT+08:00) --><h1 id="数组">数组</h1><h2 id="盛最多水的容器">盛最多水的容器</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">【LeetCode】盛最多水的容器</a></p><p>题目意思就是找到如下图所示最大的面积<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="题图">，挑战性在于希望在<span class="math inline">\(O(n)\)</span>时间复杂度内完成查找。</p><p>我的思路是使用两个指针分别指向头尾两个高度，让指向较短线段的指针向另外一个指针移动。因为移动较短线段的指针会得到一条相对较长的线段，这可以克服由宽度减小而引起的面积减小。反之则必然引起面积缩小。C++代码实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> delta=last-prev;</span><br><span class="line">    <span class="keyword">int</span> maxArea=<span class="built_in">min</span>(<span class="built_in">height</span>[prev],<span class="built_in">height</span>[last])*delta;</span><br><span class="line">    <span class="keyword">int</span> tempArea=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(delta)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height</span>[prev]&lt;=<span class="built_in">height</span>[last])&#123;</span><br><span class="line">            ++prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            --last;</span><br><span class="line">        &#125;</span><br><span class="line">        --delta;</span><br><span class="line">        tempArea=<span class="built_in">min</span>(<span class="built_in">height</span>[prev],<span class="built_in">height</span>[last])*delta;</span><br><span class="line">        maxArea=(tempArea&gt;maxArea)?tempArea:maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意到这里面用了一些涉及到编译和汇编的小trick提升了执行速度，提交界面显示执行时间超过90.70%的用户。</p><h2 id="pat-ranking">PAT Ranking</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805474338127872" target="_blank" rel="noopener">【PAT A1025】PAT Ranking</a></p><p>题目主要考察的就是模拟一个有优先级的排序算法，编写程序的过程中发现自己两点不足：</p><ol type="1"><li>cmp函数编写不熟练；</li><li>题目要求“the registration number (a 13-digit number)”，表明肯定不能直接使用int类型变量记录准考证号，应该考虑使用char字符数组记录。</li><li>vector使用不熟练，注意初始化n行元素类型为Info的二维数组应该用语句<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Info&gt;&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p>下面把cmp函数代码贴出，供以后复习参考：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Info &amp;a,<span class="keyword">const</span> Info &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score==b.score)&#123;</span><br><span class="line">        <span class="comment">//Sort by regNum in a non-decreasing </span></span><br><span class="line">        <span class="comment">//order if the scores are the same.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.regNum,b.regNum)&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="链表">链表</h1><p><em>昨天晚上临睡前突然想到反转链表的操作自己不太熟悉，然后2019年冬季PAT考试刚好考了每k个结点为一组反转链表的题目，而自己却不太会做。因此想要着手撰写这个专题，辅以LeetCode评判系统测试正确性，用以复习链表操作。</em></p><h2 id="反转链表">反转链表</h2><h3 id="反转整个链表">反转整个链表</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">【LeetCode 206】Reverse Linked List</a></p><p>题目的意思直接明了，挑战性在于要一次遍历完链表且不消耗过多的额外空间。这里主要采用三指针迭代的方式求解。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *prev=<span class="literal">NULL</span>;</span><br><span class="line">    ListNode *curr=head;</span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        ListNode *nextTemp=curr-&gt;next;</span><br><span class="line">        curr-&gt;next=prev;</span><br><span class="line">        prev=curr;</span><br><span class="line">        curr=nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="每k个结点为一组反转链表">每k个结点为一组反转链表</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">【LeetCode 25】Reverse Nodes in k-Group</a></p><p>题目的挑战性在于一次遍历就要完成每k个结点反转链表，并且只允许常数级别的额外空间。这里主要采用尾插法解题：即每次遍历到第k个结点，将该组头节点插入第k个结点后面，再将新的该组头节点插入第k个结点后面，以此类推。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* temp=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    temp-&gt;next=head;</span><br><span class="line">    ListNode* grpHead=temp;</span><br><span class="line">    ListNode* grpTail=temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(grpTail!=<span class="literal">NULL</span>&amp;&amp;count&lt;k)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">            grpTail=grpTail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grpTail==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tempHead=grpHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(grpHead-&gt;next!=grpTail)&#123;</span><br><span class="line">            ListNode *curNode=grpHead-&gt;next;</span><br><span class="line">            grpHead-&gt;next=curNode-&gt;next;</span><br><span class="line">            curNode-&gt;next=grpTail-&gt;next;</span><br><span class="line">            grpTail-&gt;next=curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        grpHead=tempHead;</span><br><span class="line">        grpTail=tempHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="移去链表末尾的第n个结点">移去链表末尾的第n个结点</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">【LeetCode 19】Remove Nth Node From End of List</a></p><p>题目意思是移除单向链表的倒数第n个结点，要求遍历一次就可以移除。这里的基本思路是双指针间隔n向后移动，达到时间复杂度<span class="math inline">\(O(n)\)</span>和空间复杂度<span class="math inline">\(O(1)\)</span>的要求。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next=head;</span><br><span class="line">    ListNode* p=head;</span><br><span class="line">    ListNode* it=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        it=it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(it==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(it!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        dummy=dummy-&gt;next;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        it=it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    dummy-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意：需要考虑删除头结点的情况，不能对所有情况都简单地返回head指针。<p></p><h2 id="两数相加">两数相加</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">【LeetCode 2】Add Two Numbers</a></p><p>依题意，把形如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出: 7 -&gt; 0 -&gt; 8</span><br><span class="line">注解: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>的两数相加。同时应该注意一些边缘条件，如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1:[], l2:[0,1], l1+l2&#x3D;[0,1]</span><br><span class="line">l1:[9,9], l2:[1], l1+l2&#x3D;[0,0,1]</span><br></pre></td></tr></table></figure>我的代码太过复杂，虽然通过了测试，但是仅优于很少的答案。因为我是以while(l1&amp;&amp;l2)作为循环条件，且没有哑结点以简化代码，所以此处贴上LeetCode官方的Java题解<sup>1</sup>，以供参考：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="队列的最大值">队列的最大值</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">【LeetCode 面试题59】队列的最大值</a></p><p>题目需要在队列的<span class="math inline">\(O(1)\)</span>时间复杂度进队出队的基础上实现一个<span class="math inline">\(O(1)\)</span>时间复杂度的求最大值操作。注意这里首先不能用优先队列（堆）实现，因为堆实现的队列出队的元素一定是最大元素，而这里要求的是按照正常的队列顺序出队。</p><p>考虑一个双端队列和一个队列，双端队列负责维护一个单调递减的队列，其队头即为当前队列内最大元素。每当进队一个元素时，如果双端队列前的元素比它小就从尾部出队，来保持双端队列的单调递减性质。同时，另外一个正常的队列负责维护所有元素。当需要出队元素时，首先检查双端队列的队头是否和正常队列队头相同，再判断需要两个队列都出队还是只要让正常队列出队。</p><p>实现代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxQueue() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(que.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deq.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(deq.empty()==<span class="literal">false</span>&amp;&amp;deq.back()&lt;value)&#123;</span><br><span class="line">            deq.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        deq.push_back(value);</span><br><span class="line">        que.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(que.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(que.front()==deq.front())&#123;</span><br><span class="line">            deq.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="线性表易错点回顾">线性表易错点回顾</h1><ul><li>数组中间位置的<strong>插入</strong>应该<strong>从数组尾往前</strong>调整元素，中间位置<strong>删除</strong>应该<strong>从删除位置往后</strong>调整元素</li><li>若用一个数组模拟两个栈，那么应该让数组的<strong>头尾</strong>作为两个栈的栈底使得数组的利用率最大</li><li>若用链表模拟栈，<strong>链表头可以作为栈顶</strong>，但是<strong>链表尾不应该作为栈顶</strong>，因为弹栈时难以维护链表尾（即新的栈顶）；同样地，若用链表模拟队列，同样<strong>不能用链表尾作为队列头</strong>，只能用<strong>链表头作为队列头，链表尾作为队列尾</strong>（队列头只删除而队列尾只插入）</li><li>多重链表的指针域有多个，但是一个结点有多个指针<strong>不一定是多重链表</strong>，如双向链表</li><li>在矩阵的多重链表表示中，第i行的head和第i列的head实际上是<strong>同一个结点</strong></li><li><p>稀疏矩阵用十字链表解决的基本数据结构，注意到tag=0时表示Head结点，用Node* next域，否则tag=1时表示Term结点，用int value域</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    Node* Down;</span><br><span class="line">    <span class="keyword">union</span> URegion&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node* next;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li>中缀转后缀？注意左括号在<strong>栈外优先级最高</strong>，但是在<strong>栈内优先级最低</strong>（因为优先级比栈顶大则压栈，否则弹栈）</li><li>数组实现的环状队列判定队列满的方法？使用n-1个数组空间，即<ul><li>入队时判定队列满：(rear+1)%maxSize==front</li><li>出队时判定队列空：front==rear</li></ul></li></ul><h2 id="参考文献">参考文献</h2><p>[1] 作者：LeetCode 链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/" target="_blank" rel="noopener" class="uri">https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/</a> 来源：力扣</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--动规专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E5%8A%A8%E8%A7%84%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 10:47:39 GMT+0800 (GMT+08:00) --><h2 id="最大子序列和的动态规划解法">最大子序列和的动态规划解法</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168" target="_blank" rel="noopener">【PAT A1007】Maximum Subsequence Sum</a></p><p>主要思路：dp数组记录最大子序列和，from数组记录以当前位置结束的极大子序列的起始下标。dp数组的递推公式为： <span class="math display">\[ dp[i]=\begin{cases} arr[0]&amp;,\ i=0\\ \max \{ dp[i-1]+arr[i],arr[i] \} &amp;,\ i&gt;0 \end{cases} \]</span> 。而from的递推公式可类比写出。注意到代码编写时有条件“dp[i-1]==0”，实际上这是依具体题目设定确定的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">from[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i<span class="number">-1</span>]+arr[i]&gt;arr[i]||dp[i<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">        from[i]=from[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dp[i]=arr[i];</span><br><span class="line">        from[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxSum&lt;dp[i])&#123;</span><br><span class="line">        maxSum=dp[i];</span><br><span class="line">        maxInd=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="零钱兑换系列">零钱兑换系列</h2><h3 id="零钱兑换">零钱兑换</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">【LeetCode 322】零钱兑换</a></p><p>题目意思是给定一个无线给定不同面额的硬币coins和一个总金额amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。</p><p>主要考虑动态规划的解法，用dp数组记录i元所需的找零数目，状态转移方程为： <span class="math display">\[ dp[i]=\begin{cases} 0&amp;,\ i=0\\ \min \{ dp[i-coins[j]]+1,\ \text{INT\_MAX} \} &amp;,\ i&gt;0 \end{cases} \]</span></p><p>注意有可能存在没有钱找零的情况，对应于dp[i-coins[j]]==INT_MAX，此时要返回-1。最终代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(coins.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>]();</span><br><span class="line">    <span class="keyword">int</span> sz=coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;++i)&#123;</span><br><span class="line">        dp[i]=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coins[j]&lt;=i&amp;&amp;dp[i-coins[j]]!=INT_MAX)&#123;</span><br><span class="line">                dp[i]=dp[i-coins[j]]+<span class="number">1</span>&lt;dp[i]?dp[i-coins[j]]+<span class="number">1</span>:dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount]==INT_MAX)?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机">买卖股票的最佳时机</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">【LeetCode 121】买卖股票的最佳时机</a></p><p>题目的意思是找到数组当中最大和最小元素差的最大值，且最小元素必须在最大元素之前。分析知道其实只需要维护一个cur_max和一个cur_min，让cur_max始终保留当前价格和cur_min差值的最大值即可。代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz=prices.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sz&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur_min=prices[<span class="number">0</span>],cur_max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sz;++i)&#123;</span><br><span class="line">        cur_max=<span class="built_in">max</span>(cur_max,prices[i]-cur_min);</span><br><span class="line">        cur_min=<span class="built_in">min</span>(cur_min,prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--数学模拟专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E6%95%B0%E5%AD%A6%E6%A8%A1%E6%8B%9F%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 10:47:39 GMT+0800 (GMT+08:00) --><h2 id="进制转换">进制转换</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344" target="_blank" rel="noopener">【PAT B1022】D进制的A+B</a></p><h3 id="p进制数x转换为十进制数y">P进制数x转换为十进制数y</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> y=<span class="number">0</span>, product=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">    y=y+(x%<span class="number">10</span>)*product;</span><br><span class="line">    x/=<span class="number">10</span>;</span><br><span class="line">    product*=P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将十进制数y转换为q进制数x">将十进制数y转换为Q进制数x</h3><p>注意一定要用<strong>do……while循环</strong>，而非while循环</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">32</span>], num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    z[num]=y%Q;</span><br><span class="line">    ++num;</span><br><span class="line">    y/=Q;</span><br><span class="line">&#125;<span class="keyword">while</span>(y!=<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>数学</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>写在一周年</title>
    <url>/%E9%82%A3%E4%B8%80%E5%B9%B4/%E5%86%99%E5%9C%A8%E4%B8%80%E5%91%A8%E5%B9%B4/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 10:47:39 GMT+0800 (GMT+08:00) --><p><em>这是2019年12月1日的推送，首发于公众号“酸辣目鱼汤”。虽然作者是我，但是编辑是她。我想将文章转载于此，暂托因新型冠状病毒肺炎疫情而不得见面的遗憾。</em></p><p><br></p><center>0</center><p><br></p><p>这是我在南京大学第三个冬天了。去年这个时候，我结交了一个人，她19岁。</p><p>我很害怕，害怕认识别人。自主招生为学弟学妹家长答疑的那个下午，我早早来到了教室，低着头，找到一个后排的座位躲了起来。“嗨！”她对我说。“嗨。”我怯生生地，心里想着这是谁呢？</p><p>福建同乡群里，她说明天回家，可是箱子好重。在食堂的我顿时陷入“茶饭不思”的状态。一个小时以后，我对自己说：这可能是一个改变你未来的决定。“我能帮你提箱子吗？”实话说，那时候的我多么希望你断然拒绝，终结我的一切念想。“好！”你说。这真是一个超纲题。</p><p><br></p><center>1</center><p><br></p><p>那个暑假很漫长，漫长得我对未来感到很绝望：要是被别人表白了怎么办，我是不是就没有机会了？我知道你的生日是9月5日，我买了你心心念念的礼物，在礼物的夹层里塞了我誊写了好几遍的情书。我把情书拿出来，又塞进去，拿出来再添了两个字，又塞进去压好——那是我一年多来写字写得最认真的时候了。</p><p>像《一千零一夜》，我把“早安”和“晚安”换着31*2=62种互不相同的方法在每个早上醒来之后和晚上睡去之前和你说。你也会回我——通常是晚上11点和中午11点。那个暑假，我要在早上8点起床和11点之间每一会儿就打开手机看看你有没有回我。有的时候，明明知道你11点才起床，但你那么久不回，我仍然会感到难过。</p><p><br></p><center>2</center><p><br></p><p>新学期每个周末的早上，我会如约等候在你的宿舍楼下，一边想着你今天会穿什么样的衣服，会梳什么样的头发，一边看着时间超过1分钟，2分钟……或许这就是可爱吧。</p><p>我们订了12月1日晚上的江苏大剧院的《戏台》。回去的路上，路程很漫长，空空荡荡的车厢外，繁星很美好。</p><p>那天晚上，我写道“其实你好多好多瞬间都可爱到我了……比如说吃东西吃着吃着嘴角就有酸奶的沫沫或者小粒的米饭、转头看我的时候黑色眼眸的扑朔迷离、夜晚地上你的晃头晃脑的影子，还有捋左边一小撮头发时候歪斜着头的模样，喝完酸奶把吸管咬得扁扁的折来折去……”</p><p><br></p><center>3</center><p><br></p><p>我发现我已经逐渐开始过起了无法脱离你的生活，一个人去食堂的时候想拿两个盘子，走在路上的时候感觉手上少提了什么，在图书馆的时候老是看看隔壁有没有你的影子，坐在地铁上，左边和右边却都是不认识的人。</p><p>有的时候未来真是一种很玄幻的东西，我们也早早开始为彼此的未来考虑、尝试去做出决定。我很爱你，我希望能够给你安稳幸福。不要离你太远，要常伴身边。要你时时快乐，要你活泼天真。可就算到了要和所有记忆握手言和的时候，我也希望你能够活在时间里，没有烟火气，笑靥如花。</p><p>或许不久之后再回来看这些文字，我还是会说自己不解风情吧。</p><p><br></p><center>4</center><p><br></p><p>最后，建议用Python运行如下神秘代码：</p>print('<!-- rebuild by neat -->]]></content>
      <categories>
        <category>那一年</category>
      </categories>
      <tags>
        <tag>那一年</tag>
      </tags>
  </entry>
  <entry>
    <title>建站撒花</title>
    <url>/%E7%AB%99%E5%8A%A1/%E5%BB%BA%E7%AB%99%E6%92%92%E8%8A%B1/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 10:47:39 GMT+0800 (GMT+08:00) --><p>欢迎来到我的小站！这是我的个人博客，您可以在这里看到我的日常生活或技术总结。我将不定时对我的博客进行更新。</p><p>如果您对我的博客感兴趣，可以打赏或者向朋友分享！如果想要与我深入交流，请给我发邮件：<a href="mailto:njulh2017@outlook.com">njulh2017@outlook.com</a>，或者访问我的个人主页：<a href="https://lajioj.github.io/haol/" class="uri">https://lajioj.github.io/haol/</a>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>站务</category>
      </categories>
      <tags>
        <tag>站务</tag>
      </tags>
  </entry>
</search>
