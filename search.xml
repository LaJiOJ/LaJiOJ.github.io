<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>信息检索</title>
    <url>/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<!-- build time:Thu Feb 27 2020 11:03:22 GMT+0800 (GMT+08:00) --><h2 id="引言">引言</h2><ul><li>考核：平时作业（实践10%）+综合实践（期末大作业20%）+闭卷考试（70%）</li><li>课程邮箱：njuir@sina.com</li><li>现代信息技术的范畴：计算机技术、通讯技术、微电子技术、传感技术</li><li>信息技术的发展节点<ul><li>语言：猿到人的重要标志</li><li>文字：信息存储和传递突破时间和空间的限制</li><li>造纸与印刷术：知识的大规模传递</li><li>电报电话电视：光（电）速带来传播效率的飞跃</li><li>计算机及现代通讯：机器开始代替人工</li></ul></li><li>信息素养：掌握了信息工具利用的知识与技能，并能够应用于解决实际问题的人</li><li>EXIF格式：记录数码照片的属性信息和拍摄数据，包含了地点信息</li><li>信息管理基本流程<ul><li>信息采集<span class="math inline">\(\rightarrow\)</span>信息加工<span class="math inline">\(\rightarrow\)</span>信息组织<span class="math inline">\(\rightarrow\)</span>信息检索<span class="math inline">\(\rightarrow\)</span>信息分析<span class="math inline">\(\rightarrow\)</span>信息预测<span class="math inline">\(\rightarrow\)</span>信息服务</li><li>无序信息<span class="math inline">\(\rightarrow\)</span>有序信息<span class="math inline">\(\rightarrow\)</span>可用信息</li></ul></li></ul><h2 id="第一章">第一章</h2><h3 id="基本概念">基本概念</h3><ul><li>数据：事实或观察的结果，是对客观事物的性质、状态以及相互关系等进行记载的物理符号，可离散（数字数据）、连续（模拟数据）<ul><li>数据需要经过解释才能体现价值</li><li>数据加工后就成为信息</li></ul></li><li>信息：（信息论、控制论和经济都有不同的解释）<ul><li>对信息进行提炼、推理后获得的正确理论是知识</li></ul></li><li>知识：正确结论、信息集合<ul><li>知识传输一般遵循的模式：传输者的知识<span class="math inline">\(\rightarrow\)</span>数据<span class="math inline">\(\rightarrow\)</span>信息<span class="math inline">\(\rightarrow\)</span>接收者的知识</li></ul></li><li>情报：（军事情报观、信息情报观、知识情报观有不同解释）</li><li>文献：用文字、图形、符号、声频、视频等技术手段记录人类知识的一种载体</li></ul><h3 id="基本概念的转换">基本概念的转换</h3><ul><li>知识--表达--&gt;数据--背景--&gt;信息--经验--&gt;知识</li></ul><h3 id="基本概念的包容">基本概念的包容</h3><ul><li>数据是事实的数字化、编码化、序列化、结构化；</li><li>信息是数据在信息媒体上的映射；</li><li>知识是对信息的加工、吸收、提取和评价的结果；</li><li>情报是特指的专业信息，是传播中的知识（知识与情报有交叉）</li><li>文献是载体</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>信息检索</category>
      </categories>
      <tags>
        <tag>大三下</tag>
        <tag>信息检索</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据实验</title>
    <url>/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<!-- build time:Thu Feb 27 2020 11:03:22 GMT+0800 (GMT+08:00) --><h2 id="课程相关">课程相关</h2><ul><li>成绩组成<ul><li>期末考试50%，基本原理、方法、概念、书面编程题</li><li>课程实验25%，5次，每次5%，共计25%</li><li>课程设计25%，暑期7月份有20多天完成</li></ul></li><li>教材：深入理解大数据——大数据编程技术与实践</li></ul><h2 id="第一章">第一章</h2><h3 id="为什么要并行计算">为什么要并行计算</h3><ul><li>提高计算机性能的主要手段<ul><li>提高处理器字长</li><li>提高集成度</li><li>流水线等微体系结构技术：实现指令级并行<ul><li>RISC结构</li><li>5级流水线</li><li>分支预测</li><li>寄存器重命名</li><li>超长指令字、乱标量等……</li></ul></li><li>提高处理器频率</li></ul></li><li>为什么需要并行计算？<ul><li>单核处理器性能提升接近极限<ul><li>VLSI集成度不可能无限制提高</li><li>ILP墙：处理器的指令级并行度提升接近极限</li><li>存储墙：处理器速度和存储器速度差异越来越大</li><li>功耗墙：功耗和散热大幅增加超过芯片承受能力</li></ul></li><li>单处理器向多核/众核并行计算发展成为必然趋势<ul><li>多（Multicore）核并行计算</li><li>众（Manycore）核并行计算</li></ul></li><li>应用领域计算规模和复杂度大幅度提高<ul><li>爆炸性增长的Web规模数据量</li><li>超大的计算量/计算复杂度</li></ul></li></ul></li></ul><h3 id="并行计算技术的分类">并行计算技术的分类</h3><ul><li>按数据和指令处理结构：弗林(Flynn)分类（体系结构角度分类）<ul><li>单指令单数据流(SISD)、单指令多数据流(SIMD)、多指令单数据流(MISD)：很少使用、多指令多数据流(MIMD)：最常用</li></ul></li><li>按并行类型（应用角度分类）<ul><li>位级并行、指令级并行、线程级并行（数据级并行、任务级并行）</li></ul></li><li>按存储访问构架<ul><li>共享内存（也称UMA）：通过总线共享内存</li><li>分布共享存储体系结构：各处理器本地有存储器，同时共享全局存储器</li><li>分布式内存：各处理器使用本地独立的存储器</li></ul></li><li>按系统类型<ul><li>多核/众核并行计算系统(MC)、对称多处理器系统(SMP)、大规模并行处理(MPP)、集群(Cluster)、网格(Grid)</li><li>上面几种系统类型中耦合度越前面越高，可扩展性越后面越高，系统规模越后面越高、能耗（一般来说与系统规模成正比）越后面越高</li></ul></li><li>按计算特征：大数据时代主要解决数据密集型和混合型并行计算<ul><li>数据密集型并行计算：如大规模Web信息搜索</li><li>计算密集型并行计算：如3D建模与渲染、气象预报、科学计算</li><li>数据密集型与计算密集型混合型并行计算：3D电影渲染</li></ul></li><li>按并行程序设计模型/方法<ul><li>共享内存变量：如pthread、OpenMp</li><li>消息传递方式：如MPI</li><li>MapReduce方式：MapReduce并行程序设计模型</li></ul></li></ul><h3 id="并行计算的主要技术问题">并行计算的主要技术问题</h3><p><em>数据怎么存，怎么算？（并行算法、软件构架、硬件构架）</em> - 多核/多处理器网络互连结构技术 - 存储访问体系结构 - 共享存储器体系结构 - 分布存储体系结构 - 分布共享存储体系结构 - 分布式数据与文件管理 - 并行计算任务分解与算法设计 - 并行程序设计模型和方法 - 共享内存式（适用共享内存结构）、消息传递式（适用分布内存结构）、MapReduce并行程序设计 - 并行程序设计语言 - 语言、库函数、接口 - 并行编译优化 - 数据同步访问和通信控制 - 可靠性技术与容错技术 - 数据失效恢复、系统和任务失效恢复 - 并行计算软件框架平台 - 提供自动化并行处理能力 - 高可拓展性和系统性能提升 - 系统性能评价和程序并行度评估 - 系统性能评价：例如Benchmark等 - 程序并行度评估 - 程序并行加速评估公式<strong>Amdahl定律,其中<span class="math inline">\(S\)</span>是加速比，<span class="math inline">\(P\)</span>是程序可并行比例、<span class="math inline">\(N\)</span>是处理器数目：（需要掌握）</strong> <span class="math display">\[S=\frac{1}{1-P+\frac{P}{N}}\]</span> - 所以，<strong>一个并行程序可加速程度是有限制的，并非无限加速，也并非程序越多越好</strong></p><h3 id="mpi并行程序设计">MPI并行程序设计</h3><ul><li>方便计算密集型，不方便数据密集型</li><li>功能：用常规语言编程方式，所有节点运行同一个程序，但处理不同的数据，提供点对点（同步、异步）、节点集合（同步、数据移动、数据规约）通信和用户自定义复合数据类型传输<ul><li>数据规约：将一组进程的数据按照指定的操作方式规约到一起并传送给一个进程，操作保证满足交换律、结合律</li></ul></li><li>MPI如何编程不是重点</li><li>MPI的特点<ul><li>灵活性好，适合于各种计算密集型的并行计算任务</li><li>独立于语言的编程规范，可移植性好</li><li>有很多开放机构或厂商实现并支持</li></ul></li><li>MPI的不足<ul><li>无良好的数据和任务划分支持</li><li>缺少分布文件系统支持分布数据存储管理（MPI只负责消息传递）</li><li>通信开销大，当计算问题复杂、节点数量很大时，难以处理，性能大幅下降</li><li>无节点失效恢复机制，一旦有节点失效，可能导致计算过程无效</li><li>缺少良好的构架支撑，程序员需要考虑以上所有细节问题，程序设计较为复杂</li></ul></li></ul><h3 id="为什么需要大数据并行处理技术">为什么需要大数据并行处理技术？</h3><ul><li>一些点<ul><li>信息检索、自然语言理解和机器学习的三个要素：数据，特征，与算法</li></ul></li></ul><h3 id="什么是大数据">什么是大数据</h3><ul><li>大数据是指无法使用常用的软件工具在一定时间内完成获取、管理和处理的数据集。</li><li>特点：4V+1C或5V(多了一个Value)<ul><li>Volume:大容量，TB-ZB</li><li>Variety:多样性</li><li>Velocity:时效性</li><li>Veracity:准确性</li><li>Complexity:复杂性</li></ul></li><li>大数据的类型：<ul><li>结构特征<ul><li>结构化数据</li><li>非结构化、半结构化数据</li></ul></li><li>获取和处理方式<ul><li>动态（流式、增量式、线上）、实时数据</li><li>静态（线下数据）、非实时数据</li></ul></li><li>关联特征<ul><li>无关联、简单关联数据（键值记录型数据）</li><li>复杂关联数据（图数据）</li></ul></li></ul></li><li>大数据研究的基本途径<ul><li>寻找新算法：降低计算复杂度</li><li>降低大数据尺度：寻找数据尺度无关算法</li><li>大数据并行化处理：分而治之</li></ul></li><li>大数据研究<ul><li>系统观点：基础设施<span class="math inline">\(\rightarrow\)</span>系统平台<span class="math inline">\(\rightarrow\)</span>算法<span class="math inline">\(\rightarrow\)</span>应用</li><li><strong>从MapReduce</strong>, BSP, MPI, CUDA, OpenMP , 定制式混合式如 MapReduce+CUDA , MapReduce+MPI<strong>变成Hadoop与Spark主流并行计算模型与系统</strong>，包括批处理计算，流式计算，图计算，迭代计算，混合式计算，定制式计算</li></ul></li><li><strong>MapReduce定义</strong>（老师的要求）：是面向大规模数据并行处理的<ul><li>基于集群的高性能并行计算平台（Cluster）</li><li>并行程序开发与运行框架（Software）</li><li>并行程序设计模型与方法（Programming Model &amp; Methodology）</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>大数据实验</category>
      </categories>
      <tags>
        <tag>大三下</tag>
        <tag>大数据实验</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘导论</title>
    <url>/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AF%BC%E8%AE%BA/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<!-- build time:Thu Feb 27 2020 11:03:22 GMT+0800 (GMT+08:00) --><h2 id="课程信息">课程信息</h2><ul><li>教材：Data Mining: Concepts and Techniques, 3rd edition. Elsevier Inc, 2012</li><li>成绩：<ul><li>Final exam 闭卷(30%)</li><li>Assignments (30%)</li><li>Data Mining Practice (40%)<ul><li>5月左右布置，有一个月左右时间完成</li></ul></li></ul></li><li>目标：锻炼数据思维<ul><li>科学研究的第四范式：基于数据的角度，“万物皆数据”</li></ul></li></ul><h2 id="引言">引言</h2><ul><li>先决条件：计算机硬件、软件技术、网络<span class="math inline">\(\rightarrow\)</span>采集数据方便且海量<span class="math inline">\(\rightarrow\)</span>大数据</li><li>为什么要数据挖掘？<ul><li>大数据有巨大的价值，Data are rich</li><li>但是大数据太多了，无法找到有用的信息，Info is poor</li></ul></li><li>数据挖掘得到什么？<ul><li>知识、关系、真理<span class="math inline">\(\rightarrow\)</span>对决策有用的信息</li></ul></li><li>举例<ul><li>超市购买商品：啤酒和尿布</li><li>潜在客户挖掘：哪些客户会从2G转化为3G？</li><li>网络入侵模式：决定当前结点正在被侵入</li><li>基因数据挖掘：通过基因表达确定基因功能</li><li>医疗数据挖掘：计算机辅助诊断</li><li>网络挖掘：网络结构、网页内容、使用习惯等用来网络搜索、用户行为检测</li><li>金融数据挖掘：欺诈检测、股票趋势发现</li><li>软件数据挖掘：挖掘源代码、运行时间等提升软件质量、生产效率、用户体验等</li><li>行为数据挖掘：Kinect</li><li>艺术数据挖掘：挖掘绘画的笔触、鉴定真伪、改变照片风格</li><li>语音生成：为无声视频产生音频</li><li>图像、视频编辑</li><li>总统竞选</li></ul></li><li>数据挖掘定义？没有确切定义<ul><li>数据挖掘是从<strong>巨量数据</strong>中获取<strong>正确的、新颖的、潜在有用的、最终可理解</strong>的模式的<strong>非平凡</strong>过程</li><li>最终可理解？其实一部分机器学习方法是不可理解的，因此一定要注意有些情况下可理解性必须要有，而有些情况下可理解性可不必有。</li></ul></li><li>Knowledge Discovery in Data(KDD)<ul><li>数据清洗、数据仓库、数据选择、数据挖掘、……</li></ul></li><li>DM和KDD的关系？<ul><li>包含、被包含、相等都有道理</li><li>现在绝大部分人认为二者都是对数据分析处理，是相同的概念</li></ul></li><li>什么数据可以被挖掘？<ul><li>&quot;Flat&quot; data: table or matrix</li><li>数据仓库（Data warehouse）</li><li>文本数据（Text data）</li><li>多媒体数据（Multimedia data）：音频、视频、图像等</li><li>网络数据（Web data）</li><li>社交网络数据（Social network data）</li><li>时间、空间数据（Temporal and spatial data）</li></ul></li><li>数据挖掘任务分类<ul><li>描述型挖掘任务：数据的总体性质，例如分布、统计量等</li><li>预测型挖掘任务：建立模型来预测未来的事件，数据量较描述型任务更多</li></ul></li><li>哪一些模式可以被挖掘？<ul><li>特征Characterization：例如提取CS学生的特征</li><li>区别Discrimination：例如对比CS和Art两个院系的学生</li><li>联系Association：例如买面包大概率也买牛奶<ul><li>挑战：找到关系</li></ul></li><li>聚类Clustering：例如根据外观把不同瓷器分成不同时期的<ul><li>挑战：找到相似度并划分</li></ul></li><li>分类Classification：例如根据外观确定一个瓷器是不是某时期的<ul><li>挑战：找到类和类的边界</li></ul></li><li>回归Regression：根据外观确定瓷器多少钱<ul><li>挑战：建立输入和输出的映射</li></ul></li><li>离群分析Outlier analysis：在现有的瓷器市场中找到古代瓷器<ul><li>挑战：对微弱信号的敏感性</li></ul></li><li>趋势和演化分析Trend and evolution analysis：找到瓷器价格改变的模式（怎么从前面的值变成现在的值）<ul><li>挑战：如何为变化的模式建立模型</li></ul></li></ul></li><li>如何评估挖掘结果？<ul><li>客观评价Objective measures：基于数据和模式结构<ul><li>例如：support and confidence</li></ul></li><li>主观评价Subjective measures：基于用户对数据的信念<ul><li>例如：unexpectedness and actionability</li></ul></li></ul></li></ul><h2 id="第二章-数据立方体与olap">第二章 数据立方体与OLAP</h2><h3 id="数据仓库">数据仓库</h3><ul><li>特点：面向主题、</li><li>数据仓库与DBMS<ul><li>DBMS：On-Line Transaction Processing联机事务处理(OLTP)</li><li>数据仓库：On-Line Analytical Processing联机分析处理(OLAP)</li></ul></li><li>数据仓库的数据模型：多维数据模型<ul><li>注意：<ul><li>维度Dimension：关心实体的不同方面<ul><li>例如：产品、市场、时间、销售量是一个四维的多维数据模型</li></ul></li><li>量Scale：该方面的大小</li></ul></li><li>多维数据模型的核心：数据立方体</li></ul></li><li>什么是数据立方体？<ul><li>数据立方体是（长方体的）格（The lattice of cuboids）</li><li>每一个晶格是一个张量（tensor）</li></ul></li><li>多维数据模型存储方式<ul><li>星型模型Star schema：事实表为中心，维表为周边</li><li>雪花模型Snowflake schema：事实表为中心，多重维表嵌套<ul><li>节省空间、牺牲性能</li></ul></li><li>事实星座模型Fact constellation schema/星系模型Galaxy schema：多个事实表、维表相连接</li><li>注意：在每一种存储方式中均包含维表(dimensional table)和事实表(fact table)</li></ul></li><li>什么是概念层级Concept hierarchy？<ul><li>例如location: all-country-province_or_state-street</li><li>层次结构说明：Schema hierarchy, set-grouping hierarchy</li></ul></li><li>数据立方体上的OLAP操作<ul><li>上卷roll-up：</li><li>下钻drill-down：</li><li>切片slice：</li><li>切块dice：</li><li>转轴pivot/旋转rotate：</li></ul></li><li>Mesaure：能够在数据立方体空间任意位置进行评估的数值函数<ul><li>通常用分布式聚合函数</li><li>三类，优先级distributive&gt;algebraic&gt;holistic<ul><li>分布式：仅分布式聚合函数<ul><li>例如：count,sum,min,max</li></ul></li><li>数值型：在分布式聚合函数得到值的基础上再次进行数值计算<ul><li>例如：avg,min_N,max_N,standard_deviation</li></ul></li><li>全面的：无法聚合的<ul><li>例如：rank,median,mode</li></ul></li></ul></li></ul></li><li>OLAP服务体系：关系OLAP(ROLAP)、多维OLAP(MOLAP)、混合OLAP(HOLAP)……</li><li>预计算：高速响应+避免重复计算<ul><li>n维数据立方体lattice有多少？<ul><li>无层次：<span class="math inline">\(T=2^n\)</span></li><li>每一维有<span class="math inline">\(L_i\)</span>层的概念层级：<span class="math inline">\(T=\prod_{i=1}^n(L_i+1)\)</span><ul><li>10维4层也有很大的开销</li></ul></li></ul></li></ul></li><li>做预计算的方法？<ul><li>不准备素材：只计算base cuboids，响应慢</li><li>完全素材：预计算所有cuboids，巨大存储开销</li><li>部分素材：预先计算一些cuboids，平衡上述两种<ul><li>基于连接频率、共享、更新等设计</li><li>一种流行的预计算方法：预先存下经常使用的素材</li></ul></li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据挖掘导论</category>
      </categories>
      <tags>
        <tag>大三下</tag>
        <tag>数据挖掘导论</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--线性表专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Thu Feb 27 2020 11:03:22 GMT+0800 (GMT+08:00) --><h1 id="数组">数组</h1><h2 id="盛最多水的容器">盛最多水的容器</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">【LeetCode】盛最多水的容器</a></p><p>题目意思就是找到如下图所示最大的面积<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="题图">，挑战性在于希望在<span class="math inline">\(O(n)\)</span>时间复杂度内完成查找。</p><p>我的思路是使用两个指针分别指向头尾两个高度，让指向较短线段的指针向另外一个指针移动。因为移动较短线段的指针会得到一条相对较长的线段，这可以克服由宽度减小而引起的面积减小。反之则必然引起面积缩小。C++代码实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> delta=last-prev;</span><br><span class="line">    <span class="keyword">int</span> maxArea=<span class="built_in">min</span>(<span class="built_in">height</span>[prev],<span class="built_in">height</span>[last])*delta;</span><br><span class="line">    <span class="keyword">int</span> tempArea=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(delta)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height</span>[prev]&lt;=<span class="built_in">height</span>[last])&#123;</span><br><span class="line">            ++prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            --last;</span><br><span class="line">        &#125;</span><br><span class="line">        --delta;</span><br><span class="line">        tempArea=<span class="built_in">min</span>(<span class="built_in">height</span>[prev],<span class="built_in">height</span>[last])*delta;</span><br><span class="line">        maxArea=(tempArea&gt;maxArea)?tempArea:maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意到这里面用了一些涉及到编译和汇编的小trick提升了执行速度，提交界面显示执行时间超过90.70%的用户。</p><h2 id="pat-ranking">PAT Ranking</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805474338127872" target="_blank" rel="noopener">【PAT A1025】PAT Ranking</a></p><p>题目主要考察的就是模拟一个有优先级的排序算法，编写程序的过程中发现自己两点不足：</p><ol type="1"><li>cmp函数编写不熟练；</li><li>题目要求“the registration number (a 13-digit number)”，表明肯定不能直接使用int类型变量记录准考证号，应该考虑使用char字符数组记录。</li><li>vector使用不熟练，注意初始化n行元素类型为Info的二维数组应该用语句<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Info&gt;&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p>下面把cmp函数代码贴出，供以后复习参考：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Info &amp;a,<span class="keyword">const</span> Info &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score==b.score)&#123;</span><br><span class="line">        <span class="comment">//Sort by regNum in a non-decreasing </span></span><br><span class="line">        <span class="comment">//order if the scores are the same.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.regNum,b.regNum)&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="链表">链表</h1><p><em>昨天晚上临睡前突然想到反转链表的操作自己不太熟悉，然后2019年冬季PAT考试刚好考了每k个结点为一组反转链表的题目，而自己却不太会做。因此想要着手撰写这个专题，辅以LeetCode评判系统测试正确性，用以复习链表操作。</em></p><h2 id="反转链表">反转链表</h2><h3 id="反转整个链表">反转整个链表</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">【LeetCode 206】Reverse Linked List</a></p><p>题目的意思直接明了，挑战性在于要一次遍历完链表且不消耗过多的额外空间。这里主要采用三指针迭代的方式求解。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *prev=<span class="literal">NULL</span>;</span><br><span class="line">    ListNode *curr=head;</span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        ListNode *nextTemp=curr-&gt;next;</span><br><span class="line">        curr-&gt;next=prev;</span><br><span class="line">        prev=curr;</span><br><span class="line">        curr=nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="每k个结点为一组反转链表">每k个结点为一组反转链表</h3><p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">【LeetCode 25】Reverse Nodes in k-Group</a></p><p>题目的挑战性在于一次遍历就要完成每k个结点反转链表，并且只允许常数级别的额外空间。这里主要采用尾插法解题：即每次遍历到第k个结点，将该组头节点插入第k个结点后面，再将新的该组头节点插入第k个结点后面，以此类推。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* temp=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    temp-&gt;next=head;</span><br><span class="line">    ListNode* grpHead=temp;</span><br><span class="line">    ListNode* grpTail=temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(grpTail!=<span class="literal">NULL</span>&amp;&amp;count&lt;k)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">            grpTail=grpTail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grpTail==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tempHead=grpHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(grpHead-&gt;next!=grpTail)&#123;</span><br><span class="line">            ListNode *curNode=grpHead-&gt;next;</span><br><span class="line">            grpHead-&gt;next=curNode-&gt;next;</span><br><span class="line">            curNode-&gt;next=grpTail-&gt;next;</span><br><span class="line">            grpTail-&gt;next=curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        grpHead=tempHead;</span><br><span class="line">        grpTail=tempHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="移去链表末尾的第n个结点">移去链表末尾的第n个结点</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">【LeetCode 19】Remove Nth Node From End of List</a></p><p>题目意思是移除单向链表的倒数第n个结点，要求遍历一次就可以移除。这里的基本思路是双指针间隔n向后移动，达到时间复杂度<span class="math inline">\(O(n)\)</span>和空间复杂度<span class="math inline">\(O(1)\)</span>的要求。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next=head;</span><br><span class="line">    ListNode* p=head;</span><br><span class="line">    ListNode* it=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        it=it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(it==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(it!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        dummy=dummy-&gt;next;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        it=it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    dummy-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意：需要考虑删除头结点的情况，不能对所有情况都简单地返回head指针。<p></p><h2 id="两数相加">两数相加</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">【LeetCode 2】Add Two Numbers</a></p><p>依题意，把形如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出: 7 -&gt; 0 -&gt; 8</span><br><span class="line">注解: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>的两数相加。同时应该注意一些边缘条件，如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1:[], l2:[0,1], l1+l2&#x3D;[0,1]</span><br><span class="line">l1:[9,9], l2:[1], l1+l2&#x3D;[0,0,1]</span><br></pre></td></tr></table></figure>我的代码太过复杂，虽然通过了测试，但是仅优于很少的答案。因为我是以while(l1&amp;&amp;l2)作为循环条件，且没有哑结点以简化代码，所以此处贴上LeetCode官方的Java题解<sup>1</sup>，以供参考：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="堆栈">堆栈</h1><h1 id="队列">队列</h1><h1 id="线性表易错点回顾">线性表易错点回顾</h1><ul><li>数组中间位置的<strong>插入</strong>应该<strong>从数组尾往前</strong>调整元素，中间位置<strong>删除</strong>应该<strong>从删除位置往后</strong>调整元素</li><li>若用一个数组模拟两个栈，那么应该让数组的<strong>头尾</strong>作为两个栈的栈底使得数组的利用率最大</li><li>若用链表模拟栈，<strong>链表头可以作为栈顶</strong>，但是<strong>链表尾不应该作为栈顶</strong>，因为弹栈时难以维护链表尾（即新的栈顶）；同样地，若用链表模拟队列，同样<strong>不能用链表尾作为队列头</strong>，只能用<strong>链表头作为队列头，链表尾作为队列尾</strong>（队列头只删除而队列尾只插入）</li><li>多重链表的指针域有多个，但是一个结点有多个指针<strong>不一定是多重链表</strong>，如双向链表</li><li>在矩阵的多重链表表示中，第i行的head和第i列的head实际上是<strong>同一个结点</strong></li><li><p>稀疏矩阵用十字链表解决的基本数据结构，注意到tag=0时表示Head结点，用Node* next域，否则tag=1时表示Term结点，用int value域</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    Node* Down;</span><br><span class="line">    <span class="keyword">union</span> URegion&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node* next;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li>中缀转后缀？注意左括号在<strong>栈外优先级最高</strong>，但是在<strong>栈内优先级最低</strong>（因为优先级比栈顶大则压栈，否则弹栈）</li><li>数组实现的环状队列判定队列满的方法？使用n-1个数组空间，即<ul><li>入队时判定队列满：(rear+1)%maxSize==front</li><li>出队时判定队列空：front==rear</li></ul></li></ul><h2 id="参考文献">参考文献</h2><p>[1] 作者：LeetCode 链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/" target="_blank" rel="noopener" class="uri">https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/</a> 来源：力扣</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--动规专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E5%8A%A8%E8%A7%84%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Thu Feb 27 2020 11:03:22 GMT+0800 (GMT+08:00) --><h2 id="最大子序列和的动态规划解法">最大子序列和的动态规划解法</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168" target="_blank" rel="noopener">【PAT A1007】Maximum Subsequence Sum</a></p><p>主要思路：dp数组记录最大子序列和，from数组记录以当前位置结束的极大子序列的起始下标。dp数组的递推公式为： <span class="math display">\[ dp[i]=\begin{cases} arr[0]&amp;,\ i=0\\ \max \{ dp[i-1]+arr[i],arr[i] \} &amp;,\ i&gt;0 \end{cases} \]</span> 。而from的递推公式可类比写出。注意到代码编写时有条件“dp[i-1]==0”，实际上这是依具体题目设定确定的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">from[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i<span class="number">-1</span>]+arr[i]&gt;arr[i]||dp[i<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">        from[i]=from[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dp[i]=arr[i];</span><br><span class="line">        from[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxSum&lt;dp[i])&#123;</span><br><span class="line">        maxSum=dp[i];</span><br><span class="line">        maxInd=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>机试知识点--数学专题</title>
    <url>/%E6%9C%BA%E8%AF%95/%E6%9C%BA%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E6%95%B0%E5%AD%A6%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Thu Feb 27 2020 11:03:22 GMT+0800 (GMT+08:00) --><h2 id="进制转换">进制转换</h2><p>题目链接：<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344" target="_blank" rel="noopener">【PAT B1022】D进制的A+B</a></p><h3 id="p进制数x转换为十进制数y">P进制数x转换为十进制数y</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> y=<span class="number">0</span>, product=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">    y=y+(x%<span class="number">10</span>)*product;</span><br><span class="line">    x/=<span class="number">10</span>;</span><br><span class="line">    product*=P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将十进制数y转换为q进制数x">将十进制数y转换为Q进制数x</h3><p>注意一定要用<strong>do……while循环</strong>，而非while循环</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">32</span>], num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    z[num]=y%Q;</span><br><span class="line">    ++num;</span><br><span class="line">    y/=Q;</span><br><span class="line">&#125;<span class="keyword">while</span>(y!=<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
        <tag>知识点</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>模式识别</title>
    <url>/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<!-- build time:Thu Feb 27 2020 11:03:22 GMT+0800 (GMT+08:00) --><h2 id="关于课程">关于课程</h2><ul><li>课程目标：理解、记忆模式识别中的基本概念、步骤和方法<ul><li>对重要方法，要能实际应用，并能理解其<strong>前提条件、应用范围、应用注意事项和方法原理及推导</strong></li><li>对讲授的其他方法，要能理解其含义和使用环境</li><li>要对模式识别的前沿领域有感性的认识</li><li>进一步能够通过独立阅读和实践掌握较深入的问题和方法，能应用到学习、研究中遇到的问题中（作业、考试不做要求）</li></ul></li><li>成绩考核：<ul><li>期末考试50-60%，作业40-50%</li><li>自愿做大作业的本科同学有适当加分（视疫情发展定）</li><li>中英文教材纠错有加分</li></ul></li><li>参考书：<ul><li>DHS/模式分类（第二版）</li><li>PRML</li></ul></li></ul><h2 id="第一章-引言">第一章 引言</h2><h3 id="引言">引言</h3><ul><li>什么是模式识别？<ul><li>PRML的定义：<strong>automatic discovery of regularities</strong> in data ... and with <strong>the use of these regularities</strong> ...</li><li>regularities: 可以是描述的一长串话，也可以是一些标签（即有规律的事物）</li></ul></li><li>模式识别的特征<ul><li>输入：数据(data, input value, ...)</li><li>输出：模式(faces, objects, words, melodies, label, categories, regularity, ...)</li><li>输入转换到输出(automatic, algorithm, assignment, ...)，这是困难的</li></ul></li><li>Autopilot、Kinect、Siri<ul><li>输入？</li><li>输出？</li><li>困难？</li></ul></li><li>输入数据的质量至关重要！（第一遍强调）</li><li>特征：被<strong>使用</strong>的数据或从原始输入数据中<strong>提取的数据</strong></li><li>评估：模式识别系统的输出与真实值比较</li><li>转换：<ul><li>常见方法：机器学习（learning from experience）</li><li>概念<ul><li>训练集：已搜集的数据</li><li>模型：从训练集得到的规律，表现形式<strong>多样</strong></li><li>测试：将这些规律应用到<strong>新</strong>的例子以得到针对该例子的结果（模式识别的输出）</li><li>测试集：为了评估这些规律搜集的数据</li></ul></li><li>对训练集和测试集的要求：交集为空</li></ul></li><li>模式识别的步骤（重要）<ul><li><strong>获取数据<span class="math inline">\(\rightarrow\)</span>提取特征<span class="math inline">\(\rightarrow\)</span>进行学习<span class="math inline">\(\rightarrow\)</span>评价评估<span class="math inline">\(\rightarrow\)</span>实际应用<span class="math inline">\(\rightarrow\)</span>获取数据</strong><ul><li>深度学习是把“提取特征”和“进行学习”合二为一<ul><li>深度学习成功的关键是提取很好的特征——表征学习</li></ul></li></ul></li><li>需要<strong>多次</strong>反馈（feedback）、尝试、修改</li><li>什么步骤最重要：<ul><li>总体来说，看情况</li><li>个人角度出发，提取特征是最重要的</li></ul></li></ul></li><li>模式识别为什么困难？<ul><li>见教材第三章</li></ul></li><li>模式识别和机器学习的区别（重要）<ul><li>模式识别：数据获取（质量高），不关注机器学习算法的理论保证，更具系统性</li><li>机器学习：假设数据符合数学、统计上的性质或约束，关注机器学习算法的理论保证</li></ul></li></ul><h3 id="进一步阅读">进一步阅读</h3><ul><li>各相关领域的最新进展可以参考其重要会议和期刊<ul><li>机器学习：JMLR,ICML,NIPS</li><li>计算机视觉：TPAMI,IJCV,CVPR,ICCV,ECCV</li><li>多媒体：ACM Multimedia, TMM</li></ul></li><li>有用的资源：<ul><li>计算机视觉、图像处理OpenCV：http://opencv.org/</li><li>Matlab：若干工具箱toolbox</li><li>深度学习软件包（百花齐放）！</li></ul></li></ul><h2 id="第二章-数学基础">第二章 数学基础</h2><p><em>此处仅列出自己不熟悉的和老师强调的内容</em></p><h3 id="线性代数与矩阵论">线性代数与矩阵论</h3><ul><li>柯西-施瓦茨不等式<ul><li>柯西不等式：<span class="math inline">\((\Sigma_{k=1}^na_kb_k)^2\leq (\Sigma_{k=1}^na_k^2)(\Sigma_{k=1}^nb_k^2)\)</span>，等号成立当且仅当<span class="math inline">\(\exists c\in \mathbb{R},\ \forall k,\ a_k=cb_k.\)</span></li><li>施瓦茨不等式：<span class="math inline">\([\int_a^bf(x)g(x)dx]^2\leq \int_a^b[f(x)]^2dx\cdot\int_a^b[f(x)]^2dx\)</span>，等号成立当且仅当<span class="math inline">\(\exists c\in \mathbb{R},\ \forall x\in [a, b],\ f(x)=cg(x).\)</span>（此处若用测度论解释则不准确）</li></ul></li><li>向量（vector）不加特殊说明时，我们认为它是一个列向量</li><li>注意：特征(feature)<span class="math inline">\(\neq\)</span>特征值(eigenvalue)/特征向量(eigenvector)</li><li>方阵的迹(trace)：<span class="math inline">\(tr(AB)=tr(BA),\ tr(ABC)=tr(BCA),\ \dots\)</span></li><li><strong>实对称矩阵</strong>：最经常用到，例如<span class="math inline">\(XX^T,\ X^TX\)</span>均为实对称矩阵，特征有：<ul><li>所有特征值都是实数，特征向量都是实向量</li><li>特征向量互相垂直：<span class="math inline">\(\xi_i^T\xi_j=0\ (i\neq j)\)</span></li><li><span class="math inline">\(E=[\xi_1\ \xi_2\ \dots\ \xi_n]\)</span>是<span class="math inline">\(n\times n\)</span>的满秩方阵，<span class="math inline">\(rank(E)=n\)</span></li></ul></li><li><strong>实对称矩阵的分解</strong>（不熟悉！）<ul><li>谱分解：<span class="math inline">\(X=\Sigma_{i=1}^n\lambda_i\xi_i\xi_i^T\)</span>（<span class="math inline">\(n\times n\)</span>矩阵，外积），<span class="math inline">\(n\)</span>个<span class="math inline">\(n\times n\)</span>的秩为1的矩阵由<span class="math inline">\(\lambda_i\)</span>加权后求和可以得到<span class="math inline">\(X\)</span>.</li><li>约定<span class="math inline">\(\|\xi_i\|=1\)</span>，则<span class="math inline">\(E\)</span>为正交矩阵</li><li><span class="math inline">\(X=E\Lambda E^T\)</span><ul><li><span class="math inline">\(\Lambda\)</span>是一个对角矩阵，<span class="math inline">\(\Lambda_{ii}=\lambda_i\)</span></li><li><span class="math inline">\(EE^T=E^TE=I,\ E^{-1}=E^T,\ |E|=1.\)</span></li></ul></li></ul></li><li>正定、半正定（本课只考虑对称的情况）<ul><li>二次型：<span class="math inline">\(x^TAx\in \mathbb{R}\)</span>，经常用到</li></ul></li><li>矩阵求导：假设导数都存在，要学会查表并合理应用<ul><li><span class="math inline">\((\dfrac{\partial \boldsymbol{a}}{\partial \boldsymbol{x}})_{ij}=\dfrac{\partial a_i}{\partial x_j}\)</span>，即Hessian矩阵.</li><li>例如<span class="math inline">\(f(\boldsymbol{a})=\boldsymbol{a}^T\boldsymbol{x}\)</span>，则<span class="math inline">\(\dfrac{\partial f}{\partial \boldsymbol{a}}=\boldsymbol{x}\)</span></li></ul></li></ul><h3 id="概率论">概率论</h3><ul><li>离散情况下概率质量函数(pmf)的概率满足<span class="math inline">\(0\leq p(x)\leq 1\)</span>；连续情况下概率密度函数(pdf)的概率满足<span class="math inline">\(p(x)\geq 0\)</span>，即可以大于<span class="math inline">\(1\)</span>.</li><li><strong>条件分布</strong>：<span class="math inline">\(P(X=x|Y=y)\)</span>：教材常用<ul><li>例如：<span class="math inline">\(Y\)</span>作为input，<span class="math inline">\(X\)</span>作为output</li></ul></li><li>期望<span class="math inline">\(E[f(x)]\)</span>：如果分布<span class="math inline">\(p(x)\)</span>及函数<span class="math inline">\(f(x)\)</span>确定，那么求出的期望是确定的，不包含随机性；<ul><li>注意：如果<span class="math inline">\(f(x,y)\)</span>仅确定<span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>不确定，那么求出的期望仍为随机变量</li></ul></li><li>*条件期望：<span class="math inline">\(E(f(\boldsymbol{x})|Y=\boldsymbol{y})=\Sigma_\boldsymbol{x}f(\boldsymbol{x})\cdot p(\boldsymbol{x}|\boldsymbol{y})\)</span></li><li>方差<ul><li><span class="math inline">\(Var(X)=E[(X-EX)^2]=E(X^2)-(EX)^2\)</span></li><li>向量形式：<span class="math inline">\(Var(X)=E[(X-EX)(X-EX)^T]\)</span>（自己和自己作外积）</li></ul></li><li>当<span class="math inline">\(p(x)\)</span>确定即随机变量分布确定，且<span class="math inline">\(f(x)\)</span>已知的情况下<ul><li>期望、方差是一个确定的数/向量/矩阵</li><li>注意：<span class="math inline">\(g(y)=E(X|Y=y)\)</span>是对<span class="math inline">\(x\)</span>求积分或求和，因此<span class="math inline">\(g(y)\)</span>与<span class="math inline">\(X\)</span>无关，是一个确定的关于<span class="math inline">\(y\)</span>的函数</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>模式识别</category>
      </categories>
      <tags>
        <tag>大三下</tag>
        <tag>模式识别</tag>
      </tags>
  </entry>
  <entry>
    <title>写在一周年</title>
    <url>/%E9%82%A3%E4%B8%80%E5%B9%B4/%E5%86%99%E5%9C%A8%E4%B8%80%E5%91%A8%E5%B9%B4/</url>
    <content><![CDATA[<!-- build time:Thu Feb 27 2020 11:03:22 GMT+0800 (GMT+08:00) --><p><em>这是2019年12月1日的推送，首发于公众号“酸辣目鱼汤”。虽然作者是我，但是编辑是她。我想将文章转载于此，暂托因新型冠状病毒肺炎疫情而不得见面的遗憾。</em></p><p><br></p><center>0</center><p><br></p><p>这是我在南京大学第三个冬天了。去年这个时候，我结交了一个人，她19岁。</p><p>我很害怕，害怕认识别人。自主招生为学弟学妹家长答疑的那个下午，我早早来到了教室，低着头，找到一个后排的座位躲了起来。“嗨！”她对我说。“嗨。”我怯生生地，心里想着这是谁呢？</p><p>福建同乡群里，她说明天回家，可是箱子好重。在食堂的我顿时陷入“茶饭不思”的状态。一个小时以后，我对自己说：这可能是一个改变你未来的决定。“我能帮你提箱子吗？”实话说，那时候的我多么希望你断然拒绝，终结我的一切念想。“好！”你说。这真是一个超纲题。</p><p><br></p><center>1</center><p><br></p><p>那个暑假很漫长，漫长得我对未来感到很绝望：要是被别人表白了怎么办，我是不是就没有机会了？我知道你的生日是9月5日，我买了你心心念念的礼物，在礼物的夹层里塞了我誊写了好几遍的情书。我把情书拿出来，又塞进去，拿出来再添了两个字，又塞进去压好——那是我一年多来写字写得最认真的时候了。</p><p>像《一千零一夜》，我把“早安”和“晚安”换着31*2=62种互不相同的方法在每个早上醒来之后和晚上睡去之前和你说。你也会回我——通常是晚上11点和中午11点。那个暑假，我要在早上8点起床和11点之间每一会儿就打开手机看看你有没有回我。有的时候，明明知道你11点才起床，但你那么久不回，我仍然会感到难过。</p><p><br></p><center>2</center><p><br></p><p>新学期每个周末的早上，我会如约等候在你的宿舍楼下，一边想着你今天会穿什么样的衣服，会梳什么样的头发，一边看着时间超过1分钟，2分钟……或许这就是可爱吧。</p><p>我们订了12月1日晚上的江苏大剧院的《戏台》。回去的路上，路程很漫长，空空荡荡的车厢外，繁星很美好。</p><p>那天晚上，我写道“其实你好多好多瞬间都可爱到我了……比如说吃东西吃着吃着嘴角就有酸奶的沫沫或者小粒的米饭、转头看我的时候黑色眼眸的扑朔迷离、夜晚地上你的晃头晃脑的影子，还有捋左边一小撮头发时候歪斜着头的模样，喝完酸奶把吸管咬得扁扁的折来折去……”</p><p><br></p><center>3</center><p><br></p><p>我发现我已经逐渐开始过起了无法脱离你的生活，一个人去食堂的时候想拿两个盘子，走在路上的时候感觉手上少提了什么，在图书馆的时候老是看看隔壁有没有你的影子，坐在地铁上，左边和右边却都是不认识的人。</p><p>有的时候未来真是一种很玄幻的东西，我们也早早开始为彼此的未来考虑、尝试去做出决定。我很爱你，我希望能够给你安稳幸福。不要离你太远，要常伴身边。要你时时快乐，要你活泼天真。可就算到了要和所有记忆握手言和的时候，我也希望你能够活在时间里，没有烟火气，笑靥如花。</p><p>或许不久之后再回来看这些文字，我还是会说自己不解风情吧。</p><p><br></p><center>4</center><p><br></p><p>最后，建议用Python运行如下神秘代码：</p>print('<!-- rebuild by neat -->]]></content>
      <categories>
        <category>那一年</category>
      </categories>
      <tags>
        <tag>那一年</tag>
      </tags>
  </entry>
  <entry>
    <title>建站撒花</title>
    <url>/%E7%AB%99%E5%8A%A1/%E5%BB%BA%E7%AB%99%E6%92%92%E8%8A%B1/</url>
    <content><![CDATA[<!-- build time:Thu Feb 27 2020 11:03:22 GMT+0800 (GMT+08:00) --><p>欢迎来到我的小站！这是我的个人博客，您可以在这里看到我的日常生活或技术总结。我将不定时对我的博客进行更新。</p><p>如果您对我的博客感兴趣，可以打赏或者向朋友分享！如果想要与我深入交流，请给我发邮件：<a href="mailto:njulh2017@outlook.com">njulh2017@outlook.com</a>，或者访问我的个人主页：<a href="https://lajioj.github.io/haol/" class="uri">https://lajioj.github.io/haol/</a>。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>站务</category>
      </categories>
      <tags>
        <tag>站务</tag>
      </tags>
  </entry>
</search>
